深入理解java虚拟机




## 第一章 走近java

**​	java技术体系包括：**java程序设计语言、各种平台上的java虚拟机、Class文件格式、JavaAPI类库、来自商业机构和开源社区的第三方java类库。

​	**JDK**: java程序设计语言，java虚拟机，javaAPI类库三部分统称为jdk(Java Develpoment Kit)

​	**JRE**:把API类库中的java SE API子集和java虚拟机这两部分称之为JRE，它是支持java运行的标准环境



******

--------------------



## 第二章 java内存区域与内存溢出异常

### 2.2运行时数据区域

![avatar](https://img-blog.csdn.net/20180501175523721?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAzMTYxODg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### 2.2.1程序计数器

​	可以看作是当前线程所执行的字节码的``行号指示器``。

> ​	字节码解释器的工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令。由于虚拟机的多线程是通过线程轮流切换并分配处理器执行时间来实现。在任一确定时刻，一个处理器只会执行一条线程中的指令。为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各线程间互不影响，独立存储，该内存区域为线程私有的内存。
>
> ​	线程执行Java方法时，计数器记录的是虚拟机字节码指令的地址；执行Native方法时，计数器值为空。

​	此内存区域是**唯一**一个java虚拟机规范中没有规定任何``OutOfMemoryError``情况的区域

#### 2.2.2 java虚拟机栈

​	java虚拟机在栈和程序计数器一样也是**线程私有**，它的**生命周期**和线程相同，虚拟机栈描述的是java执行方法的内存模型。每个方法在执行的同时都会创建一个**栈帧**用于**存储局部变量表、操作数栈、动态连接、方法出口**等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

- ``局部变量表``

  存放编译期可知的各种基本数据类型(8种)，对象引用和returnAddress类型(指向一条字节码指令地址)。

  所需内存空间在编译期完成分配

虚拟机规范中，该区域规定了两种异常情况：

- ``StackOverflowError``

  线程请求的栈深度，大于虚拟机所允许的栈深度时抛出该异常

- `` OutOfMemoryError``

  在虚拟机动态扩展(如果允许)时，无法申请到足够的内存，抛出该异常

#### 2.2.3 本地方法栈

​	与java虚拟机栈作用相似，区别在于虚拟机栈为虚拟机执行java方法(字节码)服务，本地方法栈为虚拟机使用到Native方法服务。

> 虚拟机规范中对本地方法栈使用的语言，使用方式和数据结构没有强制规定，具体的虚拟机可以自由实现它。有的虚拟机会将虚拟机栈和本地方法栈合二为一。在异常抛出上，本地方方法栈也会抛出``StackOverflowError``和``OutOfMemoryError``两种异常

#### 2.2.4 java堆

​    java堆是被线程所**共享**的一块内存区域,此内存区的***唯一用处***就是存放**对象实例**,几乎所有的对象都分配在堆上面。

> java堆是垃圾收集器管理的主要区域，很多时候也被成为“GC堆”。堆中还细分有``新生代``和``老年代``。
>
> 根据java虚拟机规范，java堆可以处在物理上不连续的内存空间中，只要逻辑上连续即可。
>
> 当前主流虚拟机大小都是可以扩展的，堆在扩展时可能会抛出``OutofMemoryError``异常。

#### 2.2.5 方法区

​    方法区与堆一样，都是各个线程所**共享**的区域，用于存储已被虚拟机加载的**类信息、常量、静态变量、即时编译后的代码**等数据。

> 虚拟机规范中将方法区描述为堆的一个逻辑部分，不过它有一个别名叫做Non-Heap(非堆)，为了将其和堆区分开来。

> 对HotSpot虚拟机而言，习惯性将方法区称为**“永久代**”，但是本质并不等价,只是用永久代来实现方法区而已。这样可能导致``内存溢出``问题

​    方法区不需要连续内存空间，可以选择固定空间或者可以扩展，还可以选择不实现**垃圾收集**。

​    此区域的内存回收目标主要是针对**常量池**的回收和对**类型的卸载**。

#### 2.2.6 运行时常量池

   运行时常量池属于方法区的一部分。

> Class文件中除了类的版本，字段、方法、接口等信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。该部分内容在类加载后进入方法区的运行时常量池存放。
>
> 翻译出来的直接引用也会存储在运行时常量池中。

> 运行时常量池另外一个重要特性是具备**动态性**,java语言并不要求常量必须要在编译期产生，运行期也可能将新的常量放入池中。例如：String类的intern()方法。
>
> 异常抛出：``OutOfMemoryError``

#### 2.2.7 直接内存

​    直接内存不是虚拟机运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域。但该区域也被频繁使用，可能抛出``OutOfMemoryError``异常

> JDK1.4中新加入NIO(New Input/Output)类，引入了一种基于通道与缓冲区的I/O方式，它使用Native库函数直接分配堆外内存，然后通过储存在java堆中的DirectByteBuffer对象对该内存引用进行操作。
>
> 这样可以显著提高性能，避免在java堆和Native堆中来回复制数据。
>
> 忽略该部分内存可能导致``OutOfMemoryError``异常。

### 2.3 HotSpot虚拟机对象探秘

#### 2.3.1 对象的创建

**步骤：**

- 虚拟机遇到一条new指令时，首先去检查该指令的参数能否在常量池中定位到一个类的符号引用，并检查该符号引用所代表的类是否已经被加载、解析和初始化过，如果没有，先执行相应类加载过程。
- 类加载检查通过后，虚拟机为新生对象分配内存。对象所需内存大小在类加载完后被确定。从java堆中划分出一块确定大小的内存给对象。
- 内存分配完成后，虚拟机将分配到的内存空间都初始化为零值(不包括对象头)。该步骤保证对象实例字段可以不赋初值就可以直接使用。
- 虚拟机对对象进行必要的设置，例如：该对象属于哪个类的实例，对象的哈希码，找到对象的元数据信息，对象的GC分代年龄等信息。该信息存在对象头中。
- 以上是虚拟机执行步骤。此后java程序会对new的对象执行<init>方法。

> 在对象分配内存空间时，存在两种方式：
>
> - **指针碰撞**：java内存规整，用过的内存在一边，空闲内存在另一边，中间放着一个指针作为分界点指示器，分配内存时就是将指针向空闲内存区挪动与对象大小相等的距离，该分配方式称为**指针碰撞**
> - **空闲列表**：如果java内存划分不规整，虚拟机必须维护一个空闲列表，在分配内存的时候将一块足够大的空间划分给对象实例，并更新列表上的记录。
>
> 选择哪种方式由java堆是否规整决定，而java堆的规整由采用的**垃圾收集器**是否带有**压缩整理**功能决定

> 对于频繁分配内存导致的安全性问题
>
> **方案一**：对分配内存空间的动作进行同步处理--实际上虚拟机采用CAS配上分配失败重试的方式保证更新操作的原子性
>
> **方案二**：将内存分配的动作按照线程划分在不同的空间进行，即每一个线程在Java堆中预先分配一小块内存，成为本地线程分配缓冲(TLAB)

#### 2.3.2 对象的内存布局

​    在HotSpot虚拟机中，对象的内存布局可以分为3块区域**：对象头、实例数据**和**对齐填充**。

​    HotSpot虚拟机中，对象头包括两部分信息：

- 第一部分用于存储对象自身运行时数据，如哈希码，GC分代年龄，锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分长度在32位和64位虚拟机中分别为32bit和64bit。
- 另一部分是类型指针，即对象指向它类元数据的指针，确定该对象是哪个类的实例。并非所有虚拟机都必须在对象数据上保留类型指针，查找对象的元数据信息并不需要经过对象本身。如果对象是java数组，对象头还必须有一块用于记录数组长度的数据.

第三部分对齐填充不是必然存在的，仅仅用作占位符。虚拟机的内存管理系统要求对象起始地址必须是8字节的整数倍，当对象实例数据部分没有对齐时，就需要对齐填充。

#### 2.3.4 对象的访问定位

​    java程序通过栈上的reference数据来操作堆上的具体对象。

> 由于reference类型在java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该用何种方式去定位、访问堆中的对象的具体位置。所以，如何访问取决于虚拟机的实现。目前存在两种主流访问方式：**使用句柄**和**直接指针**

- **使用句柄**：java堆中会划分出来一块内存作为句柄池，reference存储的就是对象的句柄地址，句柄中包含了对象实例数据(堆)与类型数据(方法区)各自的具体地址信息；
- **直接指针**：使用该方式时，java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference存储的直接就是对象地址。

> **比较**
>
> **使用句柄**访问最大的好处就是reference中存储的是稳定的句柄地址，对象被移动时只会改变句柄中实例数据指针，reference本身不需要改变
>
> **直接指针**访问好处是速度快，它节省了一次指针定位时的时间开销。HotSpot使用该方式进行对象访问



---

---



## 第三章 垃圾收集器与内存分配策略

### 3.2 对象已死吗

#### 3..2.1 引用计数法

​    给对象添加一个**引用计数器**，每当有一个地方引用它时，计数器值+1；当引用失效时，计数器值-1；任何时刻计数器为0的对象不可能再被引用

> 引用计数法实现简单，判定效率高，但是无法解决对象之间**相互循环引用问题**。

#### 3.2.2 可达性分析算法

​    主流商用语言(Java,C#)的主流实现，都是称为**可达性分析**来判定对象是否存活。基本思想是通过一系列的“GC Roots”对象作为起点，从这些节点往下搜索，搜索过的路径称为**引用链**，当一个对象到GC Roots没有任何引用链时，证明此对象不可用。

>在Java语言中，可以作为GC Roots对象的有以下几种：
>
>- 虚拟机栈中引用的对象
>- 方法区中类静态属性引用的对象
>- 方法区中常量引用的对象
>- 本地方法栈中JNI(本地Native方法)引用的对象
>
>(虚拟机栈或者方法区中引用的对象？)

#### 3.2.3 再谈引用

>  有一类对象：当内存足够时，保留在内存中；当内存经过垃圾收集后还很紧张时，可以抛弃的对象。

​    JDK1.2之后，Java对引用的概念进行了扩充，分为四种：

- **强引用**：指在程序代码中普遍存在的，类似Object obj = new Object()这种的引用，只要强引用还在，GC永远都不会回收掉被引用的对象；
- **软引用**：描述一些还有用但并非必需的对象。系统在将要内存溢出前，将会把这些对象列进回收范围进行二次回收；
- **弱引用**：弱引用的对象只生存到下一次GC之前;
- **虚引用**：虚引用不会对对象的生存时间构成影响，也无法通过虚引用获取对象实例。虚引用被对象关联的唯一目的是对象在被回收之前能够收到一个系统通知。

#### 3.2.4 生存还是死亡(对象回收判断)

​    在可达性算法中不可达对象也不是被回收的，一般来说对象被回收要经过两次标记过程：

​    如果对象在进行可达性分析后没有发现与GC Roots相连的引用链，则它被标记并进行一次筛选，条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者对象finalize()方法已经被虚拟机调用过。虚拟机认为该对象“没有必要执行”。

​    如果对象有必要执行finalize()方法，则该对象会被放置在一个叫做F-Queue队列中，并稍后由虚拟机建立一个，低优先级的Finalizer线程去执行它。线程执行时不保证会等待对象finalize()方法运行结束。在对象执行finalize方法过程中，如果对象重新与引用链上的任何一个对象建立关联，那么该对象在第二次标记时被移除“即将回收”的集合，否则，对象被回收。

> **注**：一个对象的finalize()方法只会被执行一次
>
> ​       finalize()方法不被建议使用

#### 3.2.5 回收方法区

​    永生代的垃圾收集主要有两部分内容：**废弃常量**和**无用的类**。回收废弃常量和回收java堆中的对象很相似。

> 判断一个常量是否是**废弃常量**比较简单，判定一个类是否是**无用的类**条件比较苛刻，需要同时满足以下三个条件：
>
> - 该类的所有实例都被回收
> - 加载该类的ClassLoader被回收
> - 该类对应的java.lang.class对象没有在任何地方被引用。无法在任何地方通过反射获得访问该类的方法
>
> 在大量使用反射，动态代理，GCLib等ByteCode框架，动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载功能，以保证永久代不会溢出。

### 3.3 垃圾收集算法

#### 3.3.1 标记-清除算法

​    算法分为“标记”和“清除”两个阶段：首先标记所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

> 不足：
>
> - 效率问题，标记和清除两个过程的效率都不高
> - 空间问题，标记清除后会产生大量不连续的内存碎片，碎片太多可能导致以后在程序运行过程中需要分配较大对象时，无法找到足够大的内存而不得不提前触发一次垃圾收集动作。

#### 3.3.2 复制算法

   复制算法将内存按照容量分为大小相等的两块，每次只使用其中的一块。当一块中的内存使用完后，将该内存中还存活的对象复制到另一块内存中，再将原来的内存清理掉。每次回收时都是对整个半区进行回收，不存在内存碎片问题，实现简单，运行高效，代价高昂。

>  **现代的商用虚拟机都采用该算法回收新生代**，内存划分上，将内存分为一块Eden空间和2块较小的Survivor空间，每次使用Eden和一块Survivor空间。
>
> 内存回收时，将Eden和一块Survivor上存活的对象复制到另一块Survivor上并释放空间，HotSpot中Eden和Survivor大小比例8：1。
>
> 当Survivor内存不够时，需要依赖其他内存(指老年代)进行担保分配。

#### 3.3.3 标记-整理算法

​    根据**老年代**的特点，标记过程与标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。

#### 3.3.4 分代收集算法

​    当前商业虚拟机都使用”分代收集“算法作为垃圾收集。-

### 3.4 HotSpot算法实现

#### 3.4.1 枚举根节点

> ​	从可达性分析中从GC Roots节点找引用链这个操作为例，可以作为GC Roots的节点主要在全局性的引用(常量或静态属性)与执行上下文(栈帧中的本地变量表)中，现在方法区一般都很大，如果逐个检查引用的话，会非常耗时。
>
> ​	另，可达性分析对执行时间的敏感还体现在GC停顿上，该工作必须找一个能确保一致性的快照中进行-------”一致性“的意思是整个分析期间系统看起来像被冻结在某个时间点上。不能出现分析时对象引用关系还在不断变化的情况。这一点导致GC进行时必须停顿所有java执行线程。
>
> ​	目前，主流java虚拟机使用的都是准确式GC，当执行系统停顿下来后，并不需要一个不漏的检查完所有执行上下文和全局引用的位置，虚拟机应当有办法得知哪些地方存放着对象引用。
>
> ​	HotSpot实现中，使用OopMap的数据结构来达到这一目的。在类加载完成的时候，HotSpot就把对象内什么偏移量是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时可以直接达到这些信息。

#### 3.4.2 安全点

​    在OopMap协助下，HotSpot可以快速且准确的完成GC Roots枚举，存在如下问题：

​	可能导致引用关系变化，或者说OopMap内容变化的指令非常多，为每一条指令都生成对应的OopMap，会需要大量额外空间，GC的空间成本会很高。

​    实际上，虚拟机只是在特定的位置记录这些信息，这些位置被称为**安全点**。

​	**安全点**可以被认为是在代码执行过程中的一些特殊位置，当线程执行到这些位置时，虚拟机当前的状态是安全的。

​	**安全点选择问题：**

- 程序执行时并非在所有的地方都能停顿下来GC，只有在安全点时才能暂停。**安全点**的选定不能让GC等待时间太长，也不能太过频繁以致增加系统负荷。

-  对于**安全点**，如何在GC发生时让所有线程(不包括本地native方法的线程)都运行到最近的安全点停顿下来。

  **方案**：

  - **抢断式中断**：GC发生时，先将所有线程都中断，如果有线程中断点不在安全点上，就恢复线程，让它执行到安全点。该方法目前基本没有使用。
  - **主动式中断**：当GC需要中断线程时，不直接对线程进行操作，只简单设置一个标志，各个线程执行时会轮询该标志，发现中断标志为真时就自己挂起，轮询标志点和安全点是重合的，另外再加上创建对象需要分配内存的地方。

#### 3.4.3 安全区域

​	**问题：**在线程处于睡眠或者阻塞状态时，线程无法响应GC的中断请求，执行到安全点处挂起。

​	**安全区域**是一段代码片中，引用关系不会发生变化，该区域任意地方开始GC都是安全的。安全区域可以看做是安全点的扩展。

> 线程执行到安全区域中的代码时，标识自己已经进入安全区域。这段时期内GC时，线程不需要标识自己的状态。当线程要离开安全区域时，需要检查系统是否已经完成了根节点枚举(或者整个GC过程)，如果完成，线程就继续执行，否则等待，直到线程收到可以安全离开该区域信号为止。

### 3.5 垃圾收集器

​	垃圾收集器没有最好，也没有万能的。

#### 3.5.1 Serial收集器

​	Serial收集器是最基本，古老的收集器，在jdk1.3之前是虚拟机新生代收集的唯一选择。

​	Serial收集器在执行时是**单线程**的,采用**复制算法**，并且它在工作时，**会暂停所有其他工作线程**，直到自己结束垃圾收集。

> 目前，Serial收集器依然运行在Client模式下的默认新生代收集器。
>
> **特点**：简单而高效，在单CPU环境中，它可以做到最高的单线程收集率。

> ​    用户桌面应用场景中，分配给虚拟机管理的内存不会太大，收集1-200M以内的新生代，停顿时间在毫秒级，只要不是频繁发生，该时间停顿完全可以接受。所以Serial收集器适用于Client模式下的虚拟机。

#### 3.5.2 ParNew收集器

​	ParNew收集器其实是Serial收集器的多线程版本。 相比于Serial收集器，最主要的特点是，它能够与CMS(Concurrent Mark Sweep)收集器配合工作。

​	ParNew收集器单线程执行效率小于Serial收集器。

#### 3.5.3 Parallel Scavenge 收集器

​	Parallel Scavenge 是新生代收集器，并且使用**复制算法**，又是并行的多线程收集器。

​	Parallel Scavenge 目标是达到一个可以控制的**吞吐量**，吞吐量 = 运行用户代码时间/(运行用户代码时间+垃圾收集时间)。

​	停顿时间越短越适合需要用户交互的程序，良好的响应速度可以提升用户体验，高吞吐量可以高效率的利用CPU时间，适合在后台运算而不需要太多交互的任务。

---

**老年代垃圾收集器**

---

#### 3.5.4 Serial Old 收集器

​	Serial Old是Serial收集器的老年代版本，它是**单线程收集器**，使用**标记-整理**算法。主要提供给Client模式下的虚拟机使用。

> ​    在Server模式下，它有两种用途
>
> - 在JDK1.5以前版本中与Parallel Scavenge 收集器搭配使用;
> - 作为CMS收集器的后备预案，并在并发收集发生Concurrent Mode Failure时使用。

#### 3.5.5 Parallel Old 收集器

 	它是Parallel Scavenge收集器的老年代版本，使用**标记-整理**算法。该收集器在JDK1.6之后开始提供。

>  Parallel Old收集器出现后，Parallel Scavenge收集器才可以有比较好的应用，以前Parallel Scavenge只能和Serial Old收集器配合使用。
>
> 在注重吞吐量以及CPU敏感的场合，可以优先考虑Parallel Old+Parallel Scavenge 收集器的组合

#### 3.5.6 CMS收集器

​	CMS收集器以获得最短停顿回收时间为目标。目前运用在互联网站或者B/S系统的服务端上。

​	CMS收集器基于**标记-清除**算法，运行过程分为4步：

* **初始标记**：需要停顿世界状态，仅仅标记一下GC Roots能直接关联到的对象；
* **并发标记：**进行GC Roots Tracing；
* **重新标记**：需要停顿世界状态，修正并发标记期间因用户程序运作而导致标记产生变动的那一部分对象的标记记录，停顿时间稍大于初始标记阶段；
* **并发清除**：

​	整个过程中，耗时最长的并发标记和并发清除过程收集器线程都可以和用户线程一起工作。所以，CMS收集器的内存回收是与用户线程一起**并发执行**的。

> CMS优点在于：并发收集，低停顿。
>
> 缺点：
>
> - **对CPU资源非常敏感**。CMS默认开启的回收线程数为(Cpu数量+3)/4,在CPU数小于4个时，会导致程序执行效率严重下降。解决方法为，虚拟机提供一种称为“增量式并发收集器”的CMS变种，在CPU数量不够时，让系统通过抢占式来模拟多任务机制。并发标记和并发清除时，让GC线程和用户线程交替执行。该方案效果一般，不提倡使用；
> - **CMS收集器无法处理浮动垃圾**，可能出现“Current Mode Failure”失败而导致另一次Full  GC的产生。CMS在并发清理阶段会不断产生新垃圾，该部分垃圾出现在标记过程之后，当次GC无法处理它们只能等到下次GC。
> - CMS使用**标记-清除**算法，每次GC结束后会产生大量的空间碎片，当无法找到足够大的空间来分配当前对象时，会进行一次Full GC。 Full GC在进行碎片整理时，是无法并发的，需要进行停顿。
>

#### 3.5.7 G1收集器

​	G1收集器是一款面向服务端应用的垃圾收集器，其特点如下：

- **并行与并发**：G1能充分利用多核CPU来缩短Stop-The-World停顿时间，部分其他收集器原本需要停顿Java线程执行GC动作，G1可以通过并发的方式让java程序继续执行；
- **分代收集：**G1不需要其他收集器配合就可以管理整个GC堆，但它能够采取不同方式去处理新创建的对象和已经存活一段时间，熬过多次GC的旧对象以获取更好的收集结果。
- **空间整合**：G1从整体看是基于标记-整理算法实现，从局部看是基于复制算法实现的。两种算法使得G1运作期间不会产生内存空间碎片，收集后能够提供规整的可用内存，该特性有利于程序长时间运行。
- **可预测的停顿**：G1相比较与CMS，除了追求低停顿外，还能建立可预测的时间模型，能让使用者明确指定在一个长度为M毫秒的时间片内，消耗在垃圾收集上的时间不超过N毫秒，这几乎是实时java垃圾收集器的特征了。

> 使用G1收集器时，java堆的内存布局和其他收集器有很大区别，它将整个java堆划分为多个大小相等的独立区域，虽然还保留有新生代和老年代的概念，单他们之间不再是物理隔离的，它们都是一部分区域(不需要连续)的集合。

> G1收集器的可预测停顿原因是它有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个区域里垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的区域。该方式保证了G1收集器在有限的时间内可以尽可能高的回收效率。

> G1收集器中，region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用**Remembered Set**来避免全局扫描。G1中每一个region都有一个对应的Remembered Set，虚拟机发现程序在对Referenced类型的数据进行写操作时，会产生一个Write Barrier暂时中断操作，检查Reference引用的对象是否处于不同的Region中，如果是，则将相关的引用信息记录到被引用对象所属的Region的Remembered Set中，当进行内存回收时，在GC根节点枚举范围加入Remembered Set即可保证不对全堆进行扫描。

​	G1收集器运作大致可以分为以下几个步骤：

- **初始标记：**标记GC Roots能直接关联到的对象，并且修改TAMS(Next Top at Mark Start)值,让用户在并发运行时，能够在正确可用的Region中创建新对象，该阶段需要短暂的线程停顿；
- **并发标记**：从GC Root开始对堆中对象进行可达性分析，找出存活对象，耗时较长，但可以和用户程序并发执行；
- **最终标记**：修正在并发标记期间因用户程序继续运作而导致标记发生变动的那一部分标记记录，虚拟机将此期间对象变化记录在线程Recommened Set Logs里，并最后将该数据合并到Recommended Set中。该阶段需要停顿线程，但是可以并行执行；
- **筛选回收**：首先对个各个Region的回收价值和成本进行排序，根据用户期望的GC时间停顿时间制定回收计划；

#### 3.5.8 理解GC日志

#### 3.5.9 垃圾收集器参数总结

### 3.6 内存分配与回收策略

#### 3.6.1 对象优先在Eden分配

​	大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC.

> 新生代GC(Minor GC):指发生在新生代的垃圾收集动作。因为java对象大多朝生夕灭，所以Minor GC非常频繁，一般回收速度也快；
>
> 老年代GC(Major GC/Full GC) ：指发生在老年代的GC，Major GC速度一般比Minor GC慢10倍以上；

#### 3.6.2 大对象直接进入老年代

​	大对象指需要大量连续内存空间的java对象，例如：很长的字符串以及数组，大对象容易导致提前触发GC。

#### 3.6.3 长期存活对象将进入老年代

​	虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生并且经过一次Minor GC后仍存活，并且能够被Survivor容纳，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区每经过一次Minor GC年龄就增加1,当对象年龄超过一定程度(default:15，可以设置)，就被晋升到老年代中。

#### 3.6.4 动态对象年龄判定

​	虚拟机并不严格要求对象年龄必须达到最大设定值才能晋升老年代。如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。无需达到15；

#### 3.6.5 空间担保分配

​	进行Minor GC之前，虚拟机会检查老年代最大可用连续空间是否大于新生代对象总空间，如果成立，则下次Minor GC 是安全的。如果不成立，则查看设置是否允许担保失败，如果允许，则检查老年代最大可用连续空间是否大于历次晋升代老年代对象的平均大小，如果大于，则尝试进行一次Minor GC。如果小于，则进行一次Full GC。

> 注：大部分情况下，是允许担保失败的，以免过于频繁的Full GC.



---

---



## 第四章 虚拟机性能监控与故障处理工具



---

---



## 第五章 调优案例分析与实战



---

---



## 第六章 类文件结构



---

---



## 第七章 虚拟机类加载机制

​	代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。

### 7.1 概述

​	虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，并最终形成可以被虚拟机直接使用的Java类型。

​	Java语言里，类型的加载、连接和初始化过程都是在**程序运行期间**完成的。该策略会令类加载时增加一些性能开销，但可以为Java程序提供高度灵活性。java可以扩展的语言特性就是依赖运行期间**动态加载**和**动态连接**这个特点实现的。

### 7.2 类加载的时机

​	类从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中，验证、准备、解析三个阶段称为连接。

>  **注**：类的解析阶段有可能在初始化后再开始，以便支持java语言的运行时绑定(动态绑定)

> 在初始化阶段，虚拟机规范规定了5种情况必须立即对类进行“初始化”：
>
> - 遇到new,getstatic,putstatic或invokestatic 这4条字节码指令时，如果类没有进行初始化，则先触发初始化操作。其触发场景为：new关键字实例化对象时，读取或设置一个类的静态字段时，调用一个类的静态方法时；
> - 使用java.lang.reflect包的方法对类进行反射调用的时候，如果没有初始话，需要触发类的初始化；
> - 当初始化一个类时，发现其父类没有初始化，则先触发父类的初始化；
> - 当虚拟机宕机时，用户需要指定一个要执行的主类(main()那个类)，虚拟机会先初始化该类；
> - 当使用JDK1.7动态语言支持时，如果java.lang.invoke.MethodHandle 实例最后的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则先触发其初始化。

### 7.3 类加载过程

​	详细讲解类加载过程中的加载、验证、准备、解析、初始化5个部分

#### 7.3.1 加载

​	在类加载阶段，虚拟机需要完成三件事：

- 通过一个类的全限定名获取此类的二进制字节流
- 将字节流所代表的静态存储结构转化为方法区的运行时数据结构
- 在内存中生成一个代表这个类的java.lang.class对象，作为方法区该类的各个数据访问入口

> 获取一个类的二进制字节流可以有多种方式
>
> - 从ZIP包读取，最终成为JAR，EAR，WAR格式的基础;
>
> - 从网络中获取，应用场景Applet; 
> - 运行时计算生成，例如动态代理技术
> - 其他文件生成，例如JSP应用
> - 数据库读取

​	**非数组类**加载阶段是可以自定义完成(重写类加载器的loadClass()方法)

​	**数组类**本身不通过类加载器创建而是由java虚拟机创建，但是数组类的元素类型需要靠加载器创建，其创建过程如下：

> - 如果数组的组件类型是引用类型，则递归采用本节定义的加载过程去加载组件类型
> - 如果数组的组件类型不是引用类型，虚拟机会将数组标记为与引导类加载器关联；
> - 数组类的可见性与组件类型可见性一致，如果组件类型不是引用类型，那数组类的可见性默认为public

​	类加载完成之后，虚拟机外部的二进制字节流就按照虚拟机所需要的格式，储存在方法区中，然后在内存中实例化一个java.lang.class类的对象，该对象作为程序访问方法区中的这些类型数据的外部接口。

​	类加载阶段与连接阶段是**交叉进行**的，但这些夹在加载阶段的动作，也属于连接阶段的内容

#### 7.3.2 验证

​	目的是**确保**Class文件的字节流中包含的信息符合当前虚拟机的要求，并不会危害虚拟机自身的安全。如果不检查输入的字节流，则很可能因为载入了有害的字节流而导致系统崩溃。

> 从整体来看，验证大致会完成下面4个检验动作：**文件格式验证**，**元数据验证**，**字节码验证**，**符号引用验证**
>
> - **文件格式验证**：验证字节流是否符合Class文件格式的规范，并能被当前版本的虚拟机处理
> - **元数据验证**：对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求
> - **字节码验证**：通过数据流和控制流分析，确定语义合法，在第二阶段对元数据信息中的数据类型做完校验后，本阶段对类的方法体进行校验
> - **符号引用验证**：该动作发生在虚拟机将符号引用转化为直接引用的时候，该动作在**解析阶段**发生。符号引用验证可以看作是对类自身以外的信息进行匹配性校验

#### 7.3.3 准备

​	准备阶段正式为类变量分配内存并**设置类变量初始值**的阶段，变量所使用的内存都将在方法区中分配。

> 分配的变量只包括类变量(static 修饰)，不包括实例变量，赋值是赋类型的**默认值**，具体赋值阶段在初始化操作时进行。
>
> 对于类字段的字段属性存在ConstantValue属性(final 修饰)，则直接赋值

#### 7.3.4 解析(太多了)

​	解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

> **符号引用**：用一组符号来描述所引用的目标，可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
>
> **直接引用**：可以是直接指向目标的指针，相对偏移量或一个能间接定位到目标的句柄，直接引用是和虚拟机实现的内存布局相关的

> 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

#### 7.3.5 初始化(对静态语句块以及类变量赋值)

​	初始化是类加载过程的最后一步。**到了初始化阶段，才真正开始执行类中定义的java字节码**。在准备阶段，变量已经赋过一次系统初始值，该阶段程序员通过程序指定的主观计划去初始化类变量和其他资源，换句话说，初始化阶段是执行类构造器<clinit>()方法的过程

- <clinit>()方法是编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，其收集顺序是由语句编写顺序决定的。前面的语句不能访问后面定义的变量。
- <clinit>()方法与类的构造函数不同，它不需要显示地调用父类构造函数，虚拟机会保证子类的<clinit>()方法执行前父类的<clinit>()方法已经执行完毕。第一个被执行的<clinit>()方法类肯定是java.lang.Object.
- 由于父类的<clinit>()方法先执行，父类中定义的静态语句块先于子类变量赋值操作
- <clinit>()方法对于类或接口不是必需的，如果一个类没有静态语句块也没有对变量的赋值操作，编译器可以不为该类生成<clinit>()方法。
- 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作。因此接口和类一样都生成<clinit>()方法。**但是**，接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，只有在需要使用父接口的变量时才执行父接口的<clinit>()方法；**另外**接口实现的类初始化时也不一定执行接口的<clinit>()方法。
- 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁、同步，多线程同时初始化一个类时，只会有一个线程会执行该类的<clinit>()方法，其他线程**阻塞等待**。

### 7.4 类加载器

#### 7.4.1 类与类加载器

​	类加载器用于实现类的加载动作。

> 对任意一个类，都需要由加载它的类加载器和这个类本身**一同确立**其在java虚拟机中的唯一性。每一个类加载器都有一个独立的类名称空间。比较两个类是否相等，只有在这**两个类是由同一个类加载器加载的前提下**才有意义。否则必定不相等。
>
> 类相等包括类的Class对象的equals()方法，isAssignableFrom()方法，isInstance()方法的返回结果，也包括instanceof关键字做对象所属关系判定等情况

#### 7.4.2 双亲委派模型

从虚拟机角度看，只存在两种不同的类加载器：

- **启动类加载器**：该类加载器用C++实现，是虚拟机自身一部分；
- **其他的类加载器**：由java语言实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader
  - **扩展类加载器**：由sun.misc.Launcher$ExtClassLoader实现，负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
  - **应用程序类加载器**：由sun.misc.Launcher$AppClassLoader实现，也称为系统类加载器。它负责加载用户类路径上所指定的类库。开发者可以直接使用，如果应用程序没有自定义过自己的类加载器，则它被当作程序中默认的类加载器。



![1552050802427](/home/zhou/.config/Typora/typora-user-images/1552050802427.png)

图中加载器的层次关系，成为类加载器的**双亲委派模型**，双亲委派模型要求除了顶层启动类加载器外，其余的类都应该有自己的父类加载器。类加载器之间的父子关系**不会以继承的关系来实现**，都是以**组合的关系**来复用父加载器的代码。

> 双亲委派模型的工作流程：如果一个类加载器收到了类加载请求，它首先会把该请求委派给父类加载器完成，每一个层次都是如此，因此所有的加载请求都会最终传递到顶层的启动类加载器中。只有当父类加载器反馈自己无法完成该加载请求后，子加载器才会尝试自己去加载。

> **模型优点**：首先java类随着它的类加载器一起具备了带有优先级的层次关系，例如Object类，在程序的各个类加载器中都是同一个类。它保证了java程序运行的稳定性。

#### 7.4.3 破坏双亲委派模型

​	双亲委派模型并非强制性的约束模型，而是java设计者推荐给开发者的类加载器实现方式。

>  双亲委派模型出现过3次较大规模的"被破坏"情况
>
> - JDK1.2版本发布之前，发布双亲委派模型时为了向前兼容，在java.lang.ClassLoader添加了一个新的protected方法findClass()
> - 由该模型自身的设计缺陷引起，发生在基础类需要回调用户代码的场景。设计团队引入了一个**线程上下文类加载器**。其作用可以让父类加载器请求子类加载器去完成类加载动作。
> - 由于用户对程序动态性的追求导致。用户希望应用程序能够像计算机外设那样，不用重启就能够立即使用。

OSGI模块化标准：

​	OSGi实现模块化热部署的关键是它自定义的类加载器实现机制。每一个程序模块(Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。

​	OSGi环境下，类加载器不是双亲委派模型的树状结构，而是网状结构。当收到类加载请求时，OSGi将按照以下顺序进行搜索：

- 将以java.*的类委派给父类加载器加载；(双亲委派)
- 否则，将委派列表名单内的类委派给父类加载器加载；(双亲委派)
- 否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载；(后面都是平级类加载器)
- 否则，查找当前bundle的ClassPath,使用自己的类加载器加载；
- 否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载；
- 否则，查找Dynamic Import列表的Bundle,委派给对应的Bundle类加载器加载；
- 否则，类查找失败。



## 第八章 虚拟机字节码执行引擎

### 8.1 概述

​	虚拟机与物理机：
​	物理集的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，虚拟机的执行引擎由自己实现，可以自行指定指令集与执行引擎的结构体系。并且能够执行那些不被硬件直接支持的指令集格式。

### 8.2 运行时栈帧结构

​	栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构。它是虚拟机运行时数据区中的虚拟机栈等栈元素。栈帧存储了方法的局部变量，操作数栈，动态链接，方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应这一个栈帧在虚拟机栈里从入栈到出栈的过程。

​	在编译程序代码时，栈帧需要多大的局部变量表，多深的操作数栈都已经完全确定，写入到方法表的Code属性中。因此，一个栈帧需分配多少内存，不会受到程序运行期变量数据的影响，而取决于虚拟机具体实现。

> 线程中方法调用链可能很长，但是只有栈顶的栈帧才是有效的，称为当前栈帧，与该栈帧关联的方法称为当前方法。

#### 8.2.1 局部变量表

​	一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。最大容量由Class文件的max_locals数据项确定的。

​	局部变量表以变量槽(Slot)为最小单位.每个slot的长度可以随着处理器，操作系统或虚拟机的不同而产生变化。一个Slot可以存放一个32位以内的数据类型，Java中占用32位以内的数据类型有boolean,byte,char,short,int,float,reference和returnAddress8种类型。

> reference类型有两个条件：从此引用中直接或间接的查找到对象在Java堆中的数据存放的地址索引信息；此引用中直接或间接的查找到对象所属数据类型在方法区中的存储的类型信息。

> 对于64位的数据类型，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。Java中明确的64位数据类型只有long和double两种。

> 虚拟机会使用索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的Slot数量。
>
> - 如果是32位数据类型的变量，索引n就代表了使用第N个Slot
> - 如果是64为数据类型的变量，则会同时使用n和n+1两个Slot.(不允许采取任何方式单独访问其中的任何一个)

> 局部变量表中的Slot是可以重用的，方法体中定义的变量，其作用域不一定会覆盖整个方法体。如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot可以交给其他变量使用。**作用**：节省栈空间，副作用是影响垃圾收集行为；
>
> 局部变量未赋值时，系统不会像给类变量(static修饰那种)一样赋初值，此时不可以调用局部变量。

#### 8.2.2 操作数栈

​	也称为操作栈，它是一个后入先出栈。最大栈深度在编译时决定，写入到Code属性的max_stacks数据项中。

> 当方法开始执行的时候，方法的操作数栈是空的，方法执行过程中，各种字节码指令网操作数栈中写入和提取。

> 在概念模型中，两个栈帧作为虚拟机栈的元素，是**完全相互独立**的，但虚拟机实现时，会优化。将两个栈进行部分重叠，上面操作数栈的局部变量表区与下面的操作数栈区域重叠以共用部分数据。
>
> ![1552123916600](/home/zhou/.config/Typora/typora-user-images/1552123916600.png)



#### 8.2.3 动态连接

​	每一个栈帧都包含一个指向运行时常量池中该栈帧所属方法的**引用**，持有该引用为了支持方法调用过程中的动态链接。

> Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数，这些符号引用一部分在类加载阶段或者第一次使用时转化为直接引用，称谓**静态解析**。另一部分将在每一次运行期间转化为直接引用，称为**动态连接**。

#### 8.2.4 方法返回地址

​	方法开始执行后，有两种方式可以退出该方法：

- 执行引擎遇到任意一个方法返回的字节码指令，此时有可能有返回值传递给上层调用者，成为正常完成出口。

- 方法执行过程中遇到了异常并且该异常没有在方法体内得到处理，就会导致方法退出，称为异常完成出口。

  方法退出后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息用来恢复它上层方法的执行状态。

  > 正常退出时，调用者的PC计数器的值可以作为返回地址，异常退出时，返回地址要通过异常处理器表来决定，栈帧一般不会保存这些信息。

  方法退出实际上把当前栈帧出栈，因此退出可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有)压入调用者操作数栈中，调整PC计数器值，指向方法调用后面一条指令。

#### 8.2.5 附加信息

​	虚拟机规范中允许虚拟机实现增加一些信息到栈帧中，例如：与调试相关的信息，这完全取决于虚拟机实现方式。

### 8.3 方法调用

​	方法调用不等同于方法执行。其唯一任务就是确定被调用方法的版本，暂时不涉及到方法内部的具体运行过程。

​	方法调用在Class文件里存储的只是符号引用，并非方法在实际运行时内存布局中的入口地址。java方法调用需要在运行期间才能确定目标方法的直接引用。

#### 8.3.1 解析

​	所有方法调用中的目标方法在Class文件中都是一个常量池的符号引用，在类加载的解析阶段，一部分符号引用会转化成直接引用。**但前提为**：方法在程序真正运行之前就有一个可确定的调用版本，并且该方法的调用版本在运行期是不可改变的。调用目标在程序代码写好，编译器进行编译时就必须确定下来。这类方法的调用称作**解析**。

> java语言中符合“编译期可知，运行期不可变”的方法，主要包括静态方法和私有方法两类，前者与类型直接关联，后者外部不可访问。他们的特性决定了自己都不可能通过继承或者别的方式重写其他版本。
>
> java虚拟机里提供了5条调用字节码指令：
>
> - invokestatic:调用静态方法
> - invokespecial:地用实例构造器<init>方法，私有方法和父类方法；
> - invokevirtual:调用所有的虚方法；
> - invokeinterface:调用接口方法，会在运行时再确定一个实现此接口的对象；
> - invokedynamic:先在运行时动态解析处调用点限定符索引用的方法，然后再执行该方法。
>
> ​	只要能被invokestatic 和invokespecial指令调用的方法，都可以在解析阶段中唯一确定调用的版本，符合要求的有静态方法，私有方法，实例构造器，父类方法4类。他们在类加载的时候会将符号引用解析为该方法的直接引用。这些方法称为非虚方法(包括final方法，虽然final方法是用invokevirtual指令调用)。
>
> ​	解析调用一定是静态过程，在编译期就完全确定。

#### 8.3.2 分派

​	**1. 静态分派**

​	所有依赖静态类型来定位方法执行版本的分派动作称为静态分派，其典型应用是方法重载。静态分派发生在编译阶段，因此，静态分派的动作不由虚拟机执行。方法重载时，编译器会找出一个最合适的重载方法进行调用。

​	**2. 动态分派**

​	Java虚拟机分派方法执行版本时，invokevirtual指令运行解析大致分为以下几个步骤：

- 找到操作数栈顶的第一个元素所指向的对象的**实际类型**，记作C；

- 如果在类型C中找到与常量中的描述符和简单名称相符合的方法，然后进行访问权限验证，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError;

- 否则，按照继承关系从下往上依次对C的各个父类进行第2步搜索和验证；

- 如果没有，抛出java.lang.AbstractMethodError异常；

  **3.单分派与多分派**

  Java语言的静态分派属于多分派类型，动态分派属于单分派类型。

  **4.虚拟机动态分派的实现**

​       由于动态分派非常频繁，并且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的方法，基于现实考虑，大部分实现都不会真正地进行如此频繁的搜索。

​	**常用方法**为：在类的方法区中建立一个**虚方法表**，使用虚方法表索引来代替元数据查找以提高性能。

​	虚方法表中存放各个方法的实际入口地址，如果某个方法在子类方法中没有被重写，那子类虚方法表入口地址与父类相同方法入口地址一致，指向父类实现入口。

​	实现上，具有相同签名的方法，在父类，子类的虚方法表中都应具有一样的索引号。

​	方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。

> 注：其他方法还有**内联缓存，基于类型继承关系分析技术的守护内联**的非稳定优化手段。

#### 8.3.3 动态类型语言支持

​	1.**动态类型语言**

​	动态语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期。

​	eg：PHP,Python,Ruby,JavaScript,Lisp等

 	2. JDK1.7与动态类型
 	3. java.lang.invoke包
 	4. invokedynamic指令
 	5. 掌握方法分派规则

（都没看）

#### 8.4.1 解释执行

​	只有确定java的具体实现版本和执行引擎模式时，谈解释执行还是编译执行才比较确切。

> JAVA语言中，javac编译器完成了程序代码经过词法分析，语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程，因为这部分动作是在java虚拟机外进行的，而解释器在虚拟机内部，所以java程序的**编译是半独立**实现的

#### 8.4.2基于栈的指令集与基于寄存器的指令集

#### 8.4.3 基于栈的解释器执行过程



---

---

## 第十章 早期优化

### 10.2 javac编译器

### 10.3java语法糖的味道

> 泛型在编译实现时会进行类型擦除。



---

---



## 第十一章 晚期优化

### 11.2 HotSpot虚拟机内的即时编译器

#### 11.2.1 解释器与编译器

​	解释器：程序需要迅速启动和执行时，解释器可以省去编译时间，立即执行。

​	编译器：编译器把越来越多的代码编译成本地代码后，获得更高的执行效率。

> 解释器可以节约内存，编译器可以提升效率

#### 11.2.2 编译对象与触发条件

​	运行时被即时编译器编译的“热点代码”有两类，即：

- 被多次调用的方法

- 被多次执行的循环体

  判断代码是否是热点代码，有两种方法：

  - **基于采样的热点探测**：虚拟机会周期性的检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，该方法就是”热点方法“。**优点**：简单高效，容易获取方法调用关系；**缺点**：难以精确确认方法热度，容易被干扰
  - **基于计数器的热点探测**：虚拟机为每一个方法建立计数器，统计方法执行次数，超过一定阈值即认为该方法是热点方法。优劣与上面的采样方法相反

  HotSpot采用第二种方法，并为每个方法准备了两类计数器：、

  - **方法调用计数器**：方法被调用时，先检查方法是否存在被JIT编译过的版本，存在的话，就使用编译后的本地代码来执行；调用计数器+1,并判断两个计数器数值之和是否超过阈值，超过则向及时编译器提交该方法的代码编译请求；方法调用器在一定时间内无法超过阈值，则将其计数减半，称为**计数器热度衰减**。

  - **回边计数器**：统计方法内循环体代码执行次数

#### 11.2.3 编译过程



---

---



## 第十二章 高效并发

### 12.2 硬件效率与一致性

​	**高速缓存**：基于高速缓存的存储交互很好的解决了处理器与内存的速度矛盾。也会带来**缓存一致性**问题。

​	代码优化：为了使处理器内部运算单元尽量被充分利用，处理器可能会对输入代码进行乱序执行优化，执行完后将乱序结果重组，以保证结果与顺序执行结果一致。

> 与处理器的乱序执行优化类似，java虚拟机即时编译器也有类似的指令重排序优化。

### 12.3 Java内存模型

#### 12.3.1 主内存与工作内存

​	java内存模型主要目标是定义程序中各变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量的底层细节。

> 此处变量与Java编程所说的变量有所区别，包括实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者线程私有。

​	Java内存模型规定了所有变量都存储在主内存中。每条线程还有自己的工作内存，线程工作内存保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存进行，不能直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值传递均需要通过主内存来完成

#### 12.3.3 对于volatile型变量的特殊规则

​	当一个变量定义为volatile后，它具备两个特性：

- 保证此变量对所有线程可见性(不保证操作原子性，也就不是线程安全)
- 禁止指令重排序

符合下两条规则时，volatile不需要加锁来保证原子性：

- 运算结果并不依赖变量的当前值，或者能够确保只有单一线程修改变量的值
- 变量不需要与其他状态变量共同参与不变约束

#### 12.3.4 对于long和double型变量的特殊规则

​	虚拟机可以选择不保证64位数据类型的load，store，read和write这4个操作的原子性。

> 如果多个线程共享一个未声明为volatile的long或者double类型变量，并且同时对其进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值。

​	编码时，一般是不需要将long和double变量专门声明为volatile，因为一般虚拟机都会将64位数据读写操作作为原子操作对待。

#### 12.3.5 原子性、可见性、有序性

​	原子性：由Java内存模型来直接保证原子性变量操作包括read、load、assign、use、store和write,我们大致可以认为基本数据类型的访问读写是具备原子性的。

​	可见性：指当一个线程修改了共享变量的值，其他线程能够立即获知到这个修改，保证可见性有Volatile,synchronized和fianl三个关键字。

​	有序性：由volatile和synchronized两个关键字

#### 12.3.6 先行发生原则

​	含义：如果操作A先行发生于操作B，那么操作A产生的影响能够被操作B观察到

​	java内存模型存在一些天然的先行发生关系，如果两个操作不在此列，它们的顺序就无法保证，虚拟机可以将它们随意排序。

- 程序次序规则：准确地说，是控制流顺序而不是程序代码顺序
- 管程锁定规则：一个unlock操作先行发生于后面同一个锁的lock操作
- volatile变量原则：对一个volatile变量的写操作先行发生于后面对该变量的读操作
- 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作
- 线程终止规则：线程的所有操作先行发生于此线程的终止检测
- 线程中断原则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
- 对象终结原则：一个对象的初始化完成先行发生于它的finalize()方法的开始
- 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，则操作A先行发生于操作C

### 12.4 Java与线程

#### 12.4.1 线程的实现

​	三种方式：使用内核线程实现，使用用户线程实现和使用用户线程加轻量级进程混合实现。

>  **内核线程实现**：内核线程是由操作系统内核直接支持的线程，这种线程由内核进行切换。
>
> ​	程序一般不会直接使用内核线程，而是去使用内核线程的高级接口——轻量级进程，由于每一个轻量级进程都由一个内核线程支持，只有支持内核线程才能有轻量级进程.
>
> 由于内核线程的支持，每一个轻量级进程都成为一个独立的调度单元，即一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作。
>
> 局限性：轻量级进程基于内核线程实现，各种线程操作都要进行系统调用，代价较高；其次，每一个轻量级进程都需要一个内核线程的支持，因此需要消耗一定的内核资源，系统支持的轻量级进程数量有限。

> **使用用户线程实现**：狭义的用户线程是完全建立在用户空间线程库上的线程。因此，操作时可以快速并且低消耗的，也可以支持规模更大的线程数量。
>
> 没有内核的支持，需要考虑的问题很多，实现复杂

> 使用用户线程加轻量级进程混合实现：在该模式下，用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模用户线程并发。操作系统提供的轻量级进程则作为用户线程和内核线程之间的桥梁，可以使用内核提供的线程调度功能和处理器映射。

#### 12.4.2 Java线程调度

​	协同式调度：线程执行时间由线程本身控制。最大好处是实现简单，切换操作对线程自己是可知的，没有线程同步问题。坏处:执行时间按不可控，线程阻塞会引起程序阻塞。

​	抢占式调度：每个线程由系统分配执行时间，线程的切换不由线程本身决定。该方式下线程执行时间可控，不会出现线程导致程序阻塞问题，Java使用该方式实现线程调度。

​	Java语言对线程设置了10个优先级，两个线程同时处于ready状态，优先级越高的线程越容易被系统执行。

#### 12.4.3 状态转换

​	Java定义了5种线程状态：

- 新建(New):创建后尚未启动的线程；
- 运行(Runnable):包括了操作系统线程状态中的Running和Ready,处于此状态的线程可能在执行也可能就绪等待CPU分配执行时间
- 无限期等待(Waiting):处于这种状态的线程不会被分配CPU执行时间，需要等待被其他线程显示唤醒，以下方法会让线程处于无限期等待状态：
  - 没有设置Timeout参数的Object.Wait()方法/Thred.Join()方法
  - LockSupport.park()方法
- 限期等待(TImed Waiting):该状态的线程也不会被分配CPU执行时间，不过会在一定时间后被系统自动唤醒，以下方法会让线程进入限期等待状态：
  - Thread.sleep()方法
  - 设置了Timeout参数的Object.wait()/Thread.join()方法
  - LockSupport.parkNanos()/LockSupport.parkUntil()方法
- 阻塞(Blocked):阻塞状态等待获取一个排他锁，该事件在另一个线程放弃该锁时发生
- 结束(Termianted)：已终止线程的线程状态，线程已结束执行



---

***



## 第十三章 线程安全与锁优化

### 13.2 线程安全

​	当多个线程访问同一个对象时，如果不用考虑这些线程在运行环境下的调度和执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。

### 13.3 Java语言中的线程安全

​	按照线程安全的“安全程度”由强至弱排序，可以将Java语言中的各种操作共享数据分为5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。

- 不可变：Java语言中，不可变对象一定是线程安全的。保证对象行为不影响自己状态有很多种，最简单的就是把对象中带有状态的变量都声明为final，在构造函数结束之后，它就是不可变的。
- 绝对线程安全：不管运行环境如何，调用者都不需要任何额外的同步措施
- 相对线程安全：指通常意义上所讲的线程安全，它需要保证该对象单独的操作是线程安全的，对于特定顺序的连续调用，需要在调用时使用额外的同步手段来保证调用正确性。java语言中大部分线程安全类属于这个类型，eg:Vector,HashTable,Collections的synchronizedCollection()方法包装的集合等。
- 线程兼容：指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中安全的使用
- 线程对立：无论在调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。

#### 13.3.2 线程安全的实现方法

- 互斥同步：多线程并发访问共享数据时，保证共享数据同一时刻只被一个线程使用。互斥是实现同步的一种手段，临界区、互斥量、信号量是实现互斥的方式。属于悲观并发策略

> java中最基本的互斥同步手段是synchronized关键字，synchronized关键字在编译后会在同步块前后形成monitorenter和monitorexit两个字节码指令，两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象
>
> 执行monitorenter指令时，需要尝试获取对象的锁，如果该对象未被锁定或者当前线程已经拥有了对象的锁，把锁的计数器+1；相应的，在执行monitorexit指令时会将锁计数器-1,当计数器为0时锁被释放。如果获取对象锁失败，当前线程就要阻塞等待直到另一个线程将锁释放。
>
> synchronized同步块对于同一线程是可重入的，不会出现自己锁自己的问题；其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。

> 除了synchronized外，还可以用java.util.concurrent包中的重入锁(ReentrantLock)来实现同步，并增加了高级功能：等待可中断、可实现公平锁、锁可以绑定多个条件。
>
> - 等待可中断指当持有锁的线程长期不释放锁的时候，等待的线程可以放弃等待，改为处理其他事
> - 公平锁指多线程等待同一个锁时，必须按照申请锁的顺序来依次获得锁
> - 锁绑定多个条件指一个ReentrantLock对象可以同时绑定多个Condition对象

- 非阻塞同步：乐观并发策略，先进性操作，如果产生了冲突，就采取补偿措施。需要靠硬件来完成。






























