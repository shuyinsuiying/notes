## 1.HTTP简介

​	http协议(超文本传输)是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更高效，网络传输减少。

## 2.计算机相互之间的通信

​	计算机之间通信主要是通过TCP/IP协议在因特网上进行的。

​	TCP：控制传输协议；IP：网际协议

> IP: 计算机用来相互识别的通信机制，在因特网中标识自己并收发数据包。IP协议不检查消息是否以发送的顺序到达并且没有损坏。只对IP报文头进行校验
>
> TCP： 确保数据以正确的次序到达，并且校验数据是否损环
>
> TCP/IP 协议就是两个协议的协同工作，有上下层次的关系。TCP负责应用软件和网络软件的通信，IP负责计算机之间的通信。

## 3. HTTP工作过程

​	一次HTTP操作称作一个事务，其工作流程如下：

- 地址解析：从请求路径中解析出**协议名、主机名、端口、对象路径**，在这一步，需要域名系统DNS解析域名，得到主机的IP地址。
- 封装HTTP请求数据包
- 封装TCP包，建立TCP连接
- 客户端发送请求命令：请求格式为：统一的资源标识符(URL)，协议版本号，MIME信息包括(修饰符，客户机信息+可能的内容)
- 服务器响应：响应格式：状态行(协议版本号，状态码，MIME信息)，空行(标识信息头到此结束) Content_Type应答头信息格式发送实际数据。
- 服务器关闭连接

## 4. HTTP1.1 8种请求方式

GET :请求获取有Request-URI 所标识的资源

POST：向特定资源提交数据进行处理请求。数据包含在请求体中。POST请求可能会导致新资源的创建/已有资源的修改。

PUT:向指定资源位置上传最新内容

DELETE:请求服务器删除Request-URI所标识的资源

TRACE：回显服务器收到的请求，用于测试或诊断

CONNECT：预留给能够将连接改为管道方式的代理服务器

OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法

HEAD：向服务器索要与GET请求相一致的响应，只不过响应体不会被返回。

## 5.HTTP状态码

- 1xx:指示信息——表示请求已经接收，继续处理
  - 100：客户端必须继续发出请求
  - 101:   客户端要求服务器根据请求转换HTTP协议版本
- 2xx:成功——表示请求已经被成功接收、解析
  - 200：表明请求被成功完成，所请求的资源返回给客户端
  - 201:当服务器依照客户端请求创建一个新资源时，发送此响应码
  - 202:接收和处理，但是未完成处理
  - 203:返回信息不完整或者不确定
  - 204:请求收到，但返回信息为空
  - 206:用于完成对部分Get请求的响应
- 3xx:重定向——完成请求必须进行更进一步的操作
  - 300：请求资源在服务端存在多个，服务器不知道客户端想要哪个时，发送该响应码
  - 301:资源被永久转移到另一个URL
  - 302:请求的资源被转移到新地址，但仍可通过原URL访问
  - 303:建议客户端使用其他URL访问资源
  - 304:客户端拥有该数据的缓存，可以继续使用缓存数据
  - 307:请求的资源被删除，在其他URL处．
- 4xx：客户端错误——客户端请求有错误或请求无法实现
  - 400:客户端请求有语法错误，不能被服务器所理解
  - 401:客户端请求的资源受保护，但客户端没有授权
  - 403:请求被拒绝，服务器拒绝提供服务
  - 404:服务器找不到客户端请求的资源
  - 405:客户端使用该资源不支持的方法
  - 406：客户端请求，服务器无法满足
  - 409：请求会导致服务器资源处于不一致状态，无法完成
  - 410:服务器没有请求资源，并且没有新资源地址
  - 415:客户端发送服务器不支持的请求类型
- 5xx：服务端错误——服务器未能实现合法请求
  - 500：服务器错误
  - 501:客户端请求使用服务器不支持的HTTP特性

## 6.Http请求执行７步

- 建立tcp连接
- Web浏览器向Web服务器发送请求行
- Web浏览器发送请求头
- Web服务器应答
- Web浏览器发送应答头
- Web服务器向浏览器发送数据
- Web服务器关闭连接

## 7.浏览器输入Url按回车后浏览器怎么解析

- 解析url是否合法
- 查看浏览器是否有对该url的缓存．如果有则直接显示页面内容．浏览器缓存(-操作系统缓存-路由器缓存
- 通过DNS协议解析域名
- 浏览器向服务器发起tcp连接
- 服务器处理收到的请求，将数据返回给浏览器
- 浏览器解码数据
- 浏览器请求获取嵌入html中的资源(html,css,javascript，音乐，图片)
- 浏览器发送异步请求
- 页面渲染结束

## ８．cookies和Session区别

- cookies数据保存在客户端，session保存在服务端
- cookies可以减轻服务器压力，但是不安全,可以进行cookie欺骗
- Session较为安全，但是占用服务器资源
- cookie存储最大不能超过４k，很多浏览器都限制一个站点最多保存20个cookie,session没有限制
- session保存的是对象，cookie保存的是字符串
- session不能区分路径，同一个用户访问一个网站期间，session在任何地方都可以访问到，cookie中如果设置了路径参数，同一网站中不同路径下cookie是相互访问不到的．

## 9.https交互过程

- 客户端请求服务端证，并将自己支持的一套加密规则发送给服务器
- 服务端返回自身证书与hash算法．
- 客户端验证服务端证书合法性，生成对称密钥，使用服务器公钥加密，并将加密信息发送给服务端
- 服务端使用自己的私钥获取密码，验证摘要是否一致．使用密码加密一段消息，并发送给浏览器
- 浏览器解密消息，并计算hash是否一致，握手结束



## Http协议

http/1.x缺陷

- 连接无法复用：每次请求都要经历三次握手和慢启动．三次握手在高延迟场景下影响较为明显，慢启动则对大请求影响较大．
- Head-of-Line Blocking：会导致带宽无法被充分利用，以及后续请求被阻塞．在1.x协议中，由于服务器必须按接收请求的顺序发送响应的的规则限制，如果浏览器发送两个请求，服务器必须按照顺序处理
- 协议开销大，HTTP/1.x中header内容过大，增加传输成本
- 安全因素：传输内容都是明文，无法进行身份验证

//TODO:

## http1.0和http1.1之间有什么区别

- HTTP1.1支持长连接和请求的流水线处理：1.1中可以在同一个tcp连接中传送多个http请求和响应．多个请求和响应可以重叠，同时进行
- HTTP/1.0中header和body必须一起发送，有时会造成带宽浪费现象；HTTP/1.1则在请求头引入了range头信息，允许只请求资源的某个部分
- 缓存处理：http1.0主要是用header里if-Method-Since,Expires作为缓存判断的标准．Http/1.1引入了ETag,if-None-Match等更多可供选择的缓存头来控制缓存策略．
- HOST头域：1.0中认为每台服务器绑定一个惟一的IP地址，请求消息中的URL没有传递主机名，但是存在一台服务器上有多个主机的情况．HTTP1.1请求消息和相应消息都支持Host头域，请求消息中如果没有Host头域会报错(400 Bad Request)
- 新增错误状态码：新增了24个错误状态码(100：Coninue；101;Switching Protocols:服务器将请求转换到另一种协议;405：Method Not Allowed;406:Not Acceptable; 408:Request TimeOut)

HTTP/2.0新特性

- 多路复用：一个连接可以并行处理多个请求
- Header压缩：使用encoder来压缩需要传输的header大小
- 服务器推送：服务器会把客户端需要的资源一起推送过来，一次http就可以得到全部资源
- 解析格式：HTTP2.0将以前的基于文本的解析，改成基于二进制格式的解析

## Http中Get和Post区别

Get用于获取信息，具有幂等性，并且可以缓存；Post用于修改服务器数据，有副作用，非幂等，不可缓存．

- Get和Post只是http协议中两种请求方式，其传输协议一样，在传输上没有区别
- 报文格式上，Get参数放在Url中，Post参数放在Body中
- 传参时，Get有最大长度限制，Post没有，该限制是浏览器和服务器的限制，并非http协议的限制
- 安全性上，Get低于Post,但二者均不安全

## Cookie被禁用后如何使用session

- 进行url重写，将sessionid添加到url路径后

  > http://www.test.com/test;jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764

- 表单隐藏字段．服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把sessionid传递给服务器

​	

## HTTP协议格式

http协议格式通过URI,Request,Response等方面进行解析

- URI(统一资源标识符): 建立连接和传输数据．URL(统一资源定位符)是一种特殊的URI.一个完整URL包含以下几部分：

  举例：<http://www.fishbay.cn:80/mix/76.html?name=kelvin&password=123456#first>

  - 协议部分：http:
  - 域名部分：www.fishbay.cn.发送请求时，需要通过DNS解析转化成IP
  - 端口部分：80,该部分不是必须的，如果端口为80，可以省略不写
  - 虚拟目录部分：从域名的第一个'/'开始到最后一个'/'为止．非必须．例：/mix/
  - 文件名部分：域名最后一个'/'到'?'为止，如果没有'?',则到'#'结束；如果也没有'#',则到最后结束．本例：76.html就是
  - 锚部分:从'#'开始到最后．非必须
  - 参数部分:从?开始到#为止之间的部分是参数部分，又称为搜索部分、查询部分。本例中的参数是name=kelvin&password=123456，如果有多个参数，各个参数之间用&作为分隔符。

- Request:http请求包括：请求行，请求头，空行和请求数据四部分．

  ```http
  GET /mix/76.html?name=kelvin&password=123456 HTTP/1.1
  Host: www.fishbay.cn
  Upgrade-Insecure-Requests: 1
  User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36
  Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8
  Accept-Encoding: gzip, deflate, sdch
  Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
  ```

  - 请求行：Get请求类型，/mix...后为访问的资源，http/1.1协议版本
  - 请求头：
    - host:主机域名
    - User-agent：客户端信息
  - 空行：请求头后面必须有一个空行
  - 请求数据：请求体，可以添加任意其他数据，本例为空

- Response:包括状态行，响应头，空行，响应体

  ```http
  HTTP/1.1 200 OK
  Server: nginx
  Date: Mon, 20 Feb 2017 09:13:59 GMT
  Content-Type: text/plain;charset=UTF-8
  Vary: Accept-Encoding
  Cache-Control: no-store
  Pragrma: no-cache
  Expires: Thu, 01 Jan 1970 00:00:00 GMT
  Cache-Control: no-cache
  Content-Encoding: gzip
  Transfer-Encoding: chunked
  Proxy-Connection: Keep-alive
  //空行
  {“code”:200,“notice”:0,“follow”:0,“forward”:0,“msg”:0,“comment”:0,“pushMsg”:null,“friend”:{“snsCount”:0,“count”:0,“celebrityCount”:0},“lastPrivateMsg”:null,“event”:0,“newProgramCount”:0,“createDJRadioCount”:0,“newTheme”:true}
  ```

  - 状态行：协议版本，状态码，状态消息
  - 响应头：客户端可以使用的一些信息：date(日期)，Content-Type(MIME类型和编码格式),Connection(连接方式)
  - 空行：响应头和响应体之间必须有一个空行
  - 响应体：响应正文

- 状态码



## http与https的区别







## RPC相关

### 定义

rpc(remote Procedure Call)远程过程调用协议．它是一种通过网络从远程计算机程序上请求服务而不需要了解底层通信细节的协议．即：RPC能够使得程序像访问本地系统资源一样，访问远端系统资源．

### 架构组件

- 客户端(client)：服务调用方
- 客户端存根(client stub)：存放服务器地址信息，将客户端请求打包，并通过网络发送给服务端
- 服务端存根(server stub)：接收客户端发送过来的消息并解码，根据消息请求，调用本地服务
- 服务端(server)：服务提供者

### 调用过程

- 客户端(client)通过调用本地服务的方式调用需要的消费服务
- 客户端存根接收到调用请求后将方法，参数等信息编码序列化
- 客户端存根找到远程服务地址，将消息发送给远程服务端
- 服务端存根接收到消息，对消息进行解码反序列化
- 服务端存根根据消息类型，调用本地服务进行相关处理
- 服务端存根将处理结果序列化，并返回给客户端存根
- 客户端存根接收到服务端消息，反序列化后，将执行结果返回给客户端

### 需要技术

动态代理：也就是方法映射，在进行RPC调用过程中，需要告知服务端调用方法函数，因此，通信双方都需要有一张相同的函数映射表，以实现函数绑定．

序列化与反序列化：用于对消息的编码解码．

网络传输：由于客户端和服务端不在同一主机上，所以双方需要进行网络通信来实现信息交互．网络层需要将客户端信息传递给服务端，并且将服务端调用结果返回给客户端．RPC网络协议中大部分使用TCP协议，UDP协议也是可以的，gRPC使用的http2.0





















