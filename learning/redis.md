## Redis面试题

#### １.什么是Redis

redis是一个使用C语言编写的开源key-value数据库，支持string,list,set,zSet(有序集合)hash类型存储．这些类型均支持push/pop，add/remove及取焦急并集和差集等更丰富的操作，这些操作都是原子性．为保证效率，数据都是缓存在内存中，并且reids会周期性把更新的数据写入磁盘或者把修改操作写入追加的记录文件，在此基础上实现master-slave主从同步．

#### ２.Redis和Memcached区别与比较

- Redis支持多样的数据类型存储，而memcache只支持简单类型string
- Redis支持数据备份
- Redis支持数据持久化，而memcache数据全部存储在内存中
- redis速度快于memcached
- memcached是多线程，非阻塞ＩＯ复用网络模型；Redis使用单线程IO复用模型；

#### 3.Redis优势

- 速度快：数据存储在内存中
- 支持丰富的数据类型：String,list,set,sortedSet,hash
- 支持事务：操作原子性
- 支持消息过期：过期后会自动删除

#### ４.MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据（redis有哪些数据淘汰策略？？？）

　　　相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。redis 提供 6种数据淘汰策略：
1. volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
5. allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
6. no-enviction（驱逐）：禁止驱逐数据

#### 5.Redis分布式锁

使用Redis实现分布式锁，先用setnx指令去竞争锁，拿到锁后调用expire释放锁，由于分别两条指令可能会引起死锁问题，故需要将两条指令合并在一起当作原子性调用(有set命令实现); 

问题：

- 指令非原子性：Redis2.6.12以上版本为set指令增加了可选参数，伪代码如下：set(key,1,30,NX)可以取代setnx指令实现加锁，设置过期时间的原子性操作
- 线程执行完可以显示释放锁，释放锁时需要判断当前锁是否是自己持有的问题：判断与释放锁是两个操作，通过Lua脚本可以实现原子操作。
- 过期时间到之后，可能出现当前线程还没有执行完的情况

#### 6．Redis持久化几种方式

- 快照

  Redis把数据快照存放在一个rdb文件中，并在启动时加载该rdb文件，恢复之前保存的数据．可以自行设置持久化策略，如：每隔多少秒/每更新多少条数据，就写入磁盘．

  方式：

  redis开启一个子进程，子进程会将数据写到一个临时rdb文件，写入完成后，用新文件替换老文件

  - 优点：对性能影响最小．Redis会fork一个子进程来进行快照保存，几乎不影响正常服务
    - 每次快照会生成一个完整的数据快照文件，可以保存多个时间点的快照，提供灾难恢复；
    - 数据恢复比AOF方式快
  - 缺点：快照定期生成，Redis Crash时可能丢失部分数据
    - 单核CPU情况下，会影响正常服务效率

- AOF

  该方式Redis会把每一个写请求都记录在一个日志文件里，Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据最新．AOF默认是关闭的．AOF是可以重写的，能够只保留把数据恢复到最新状态的最小读写集．

  AOF写入时有三种选择：

  １.不进行fsync，将flush文件时机交由OS决定

  2.没写入一条日志就进行一次fsync操作，数据安全性最高，速度最慢

  3.每秒fsync一次

  - 优点：安全性高，文件易读，可修改
  - 缺点：文件比RDB文件更大，性能消耗高于RDB,数据恢复速度慢于RDB

bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，优先使用aof来恢复内存的状态，如果没有aof日志，就会使用rdb文件来恢复。
如果再问aof文件过大恢复时间过长怎么办？你告诉面试官，Redis会定期做aof重写，压缩aof文件日志大小。如果面试官不够满意，再拿出杀手锏答案，Redis4.0之后有了混合持久化的功能，将bgsave的全量和aof的增量做了融合处理，这样既保证了恢复的效率又兼顾了数据的安全性。这个功能甚至很多面试官都不知道，他们肯定会对你刮目相看。

如果对方追问那如果突然机器掉电会怎样？取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。

#### 7.Redis性能常见问题

- Master节点最好做持久化工作(rdb与AOF)
- 保证Redis主从复制连接和稳定性，应将slave与master在同一局域网
- 确保Redis没有执行耗时长的指令，因为Redis事单线程串行执行的
- 使用pipelining将连续执行的指令组合执行
- 避免从压力很大的主库上增加从库

#### 8.Redis并发竞争key的解决方案

- 分布式锁＋时间戳：竞争去写该key的时候，需要拿到该key对应的锁，并设置时间戳，修改完释放锁
- 消息队列：通过消息中间件，将并行读写串行化．将消息放到一个List/Set中，使其串行化．
- 乐观锁方式：使用Redis的watch命令．watch可以监控该key值，如果后续有事务也要修改该watch监控的值时，该事务不会被执行

#### 9.Redis缓存穿透，缓存击穿，缓存雪崩

- 缓存穿透：指查询一个根本不存在的数据，缓存层和存储层均不命中，通常，从存储层查询不到的数据不写入缓存，这样导致每次请求不存在的数据都会去查询数据库，造成缓存穿透

  > 解决方法为：
  >
  > １.可以在缓存中添加该key，并把Value设置为null，同时设置一个较短的缓存失效时间．
  >
  > ２.设置布隆过滤器

- 缓存雪崩：指大量缓存集中在一段时间内失效，发生大量缓存穿透，所有数据都向数据库去查询，造成缓存雪崩

  > 方法：
  >
  > 修改缓存失效时间，使得其均匀分布
  >
  > 使用分布式锁/队列的方式保证缓存的串行访问
  >
  > 考虑使用二级缓存

- 缓存击穿：热点key在某个特殊场景时间失效，此时恰好有大量并发请求，造成db压力

  > 解决方法：
  >
  > 加锁
  >
  > 将热点key设置成永不过期，并且在缓存对象上增加一个属性标识超时时间，当获取该数据时，查看是否要超时，如果是，则异步发起一个线程去更新该缓存．

#### 10.Redis做异步队列

一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。
如果对方追问可不可以不用sleep呢？list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。
如果对方追问能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。
如果对方追问pub/sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。

如果对方追问redis如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理



#### 11.Redis同步机制

**全量同步**

Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下： 
- 从服务器连接主服务器，发送SYNC命令； 

- 主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； 

- 主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； 

- 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； 

- 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； 

- 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；

- **增量同步**

  Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。 
  增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。

  **Redis主从同步策略**

  主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。

#### 12．Redis跳跃表与平衡二叉树,hash表相比，优点？

- hash表不适合做范围查找
- 范围查找时，平衡二叉树比跳跃表复杂
- 平衡二叉树插入，删除可能引起树的调整，跳跃表只需要修改邻节点指针
- 跳跃表内存占用优于平衡二叉树

#### 13.Redis 数据类型底层存储

- String

  ```c
  struct sdshdr{
   unsigned int len;//数组长度
   unsigned int free;//数组剩余空间
   char buf[];   
  }
  ```

  优势：

  - 常数复杂度获取字符长度
  - 避免缓冲区溢出
  - 减少修改字符操作
  - 二进制安全
  - 兼容部分C字符串

- List(双向链表):

  ```C
  typedef	struct ListNode{
      struct ListNode *pre;
      struct ListNode *next;
      void *value;
  }ListNode;
  ```

- 字典：用作数据库/hash类型

  ```C
  typedef struct dicht{
      dictEntry **table;
      unsigned long size;
      unsigned long sizemask; //hash表大小掩码，用于计算索引
      unsigned long used;　//已有节点数量
  }dictht;
  typedef struct dictEntry{
      void *key;
      union{
          void *val;
          uint64_t u64;
          int64_t s64;
          double d;
      } v;
      struct dictEntry *next;
  }dictEntry;
  ```

- 跳跃表：作为有序集合的底层实现之一

  ```C
  typedef struct zskiplistNode{
      robj *obj;//Redis对象,必须指向一个字符串对象
      double score;  //分值，用于内部节点排序
      struct zskiplistNode *backward;　//后退指针，用于逆序遍历
      struct zskiplistLevel{
          struct zskiplistNode *forward;　　//前进指针，指向对应level的下一个节点
          unsigned int span;　//跨度，用于标记跨越节点数
      }level[];
  }zskiplistNode;
  typedef struct zskiplist{
      struct zskiplistNode *header, *tail;
      unsigned long length;　//记录表长度
      int level;　//保存跳跃表中层高最大节点的层高值
  }zskiplist;
  
  ```

- 整数集合

  ```c
  typedef struct intset{
      uint32_t encoding; //如果是int整型数的话，contents每４项代表一个int整型数
      uint32_t length;
      int8_t contents[];//用于存储整数，从小到大排列且不包含重复项
  }intset;
  ```

  数组存在升级现象int16->int32->int64，并且不会降级

- 压缩列表：当一个列表键只包含少量列表项，并且每一个列表项是小整数或者短的字符串，那么会使用压缩列表作为列表键的底层实现．

Redis中的对象：

```C
typedef struct	redisObject{
    unsigned type:4; //对象类型
    unsigned encoding:4;
    unsigned lru:REDIS_LR_BITS;
    int refcount;
    void *ptr; //指向底层的数据结构
}robj;
```

Redis对象底层数据结构

底层数据结构有八种

| 编码常量                  | 对应的底层数据结构         |
| ------------------------- | -------------------------- |
| REDIS_ENCODING_INT        | long类型的整数             |
| REDIS_ENCODING_EMBSTR     | embstr编码的简单动态字符串 |
| REDIS_ENCODING_RAW        | 简单动态字符串             |
| REDIS_ENCODING_HT         | 字典                       |
| REDIS_ENCODING_LINKEDLIST | 双端链表                   |
| REDIS_ENCODING_ZIPLIST    | 压缩列表                   |
| REDIS_ENCODING_INTSET     | 整数集合                   |
| REDIS_ENCODING_SKIPLIST   | 跳跃表和字典               |

- 字符串对象：可以是int/raw/embstr．如果字符串是整数，并且可以用long型表示，那么字串编码为int，如果字串长度大于39字节，使用动态字串保存，编码设置为raw．

  - embstr创建时只需要分配内存，raw为两次(为sds分配对象，以及为object分配对象，embstr只有第二次)
  - 释放时，embstr也只需要一次
  - embstr将object和sds放在一起，可以更好地利用缓存带来的优势

- 列表对象：可以是ziplist或者linkedlist．

  - 列表对象所保存的字符串长度小于64字节并且列表保存的元素数量小于512个时，使用ziplist编码，否则使用linkedList.

- 哈希对象：编码可以是ziplist/hashtable

- 集合对象：编码可以是intset/hashtable．

- 集合有序对象：编码可以是ziplist/(skiplist+hashtable）

  - skiplist编码的有序集合对象使用zset作为底层实现，一个zset结构同时包含一个字典和一个跳跃表

    ```c
    typedef struct zset{
     	dict *dict;
        zskiplist *zsl;
    }zset;
    ```

    zset里zsl按照分值从小到大保存了所有集合元素，每一个跳跃表节点保存一个集合元素．

  zset里包含一个字典一个跳表，所以可以在O(1)时间内找到指定键值对元素，并且可以实现范围查找

#### 14.Redis每种数据结构应用场景

- **String**:最基本的类型，一个key对应一个value．value不仅可以是String,也可以是其他数据，比如:数字，图片，序列化对象.一个String最大存储量为512M．
  - 常用命令：get,set,incr,mget等
  - 使用场景：常规Key-value缓存应用．常规计数：微薄数，粉丝数．
- **Hash**:键值对集合，Hash是一个String类型的field和value的映射表．适合存储对象．
  - 常用命令：hget,hset,hgetall等
  - 应用场景：存储对象，而不需要对对象进行序列化反序列化．如果一个map内对象field很多，遍历会比较耗时．
- **list**:简单字符串列表，按照插入顺序排序，可以添加一个元素到列表头部或者尾部．本质是一个双向链表
  - 常用命令：lpush/rpush,lpop/rpop,lrange(获取列表片段)
  - 应用场景：用户的关注列表，消息队列
- **set**:string类型无序集合，通过hashtable实现．可以取交集,并集，差集等．
  - 常用命令：sadd,spop,smembers,sunion等
  - 应用场景：需要集合去重功能的场景，例如：用户之间的共同关注
- **zset**:与set一样也是srting集合．
  - 常用命令：zadd，zrange,zrem,zcard
  - 应用场景：zset是排序的集合，对集合需要排序时，可以使用．其内部实现是使用hashmap+skipList来保证数据存储和有序，hashMap中存放score映射，跳跃表中存放所有成员，排序依据是hashmap中的score．用于排行榜，带权重的消息队列

#### 15.Redis与数据库一致性问题

Redis做缓存会出现和底层数据库不一致问题，解决办法：

- **双删+超时**：在写入数据前后都进行Redis.del(key)操作.写入操作后，间隔很短时间再删除一次缓存．
  - 弊端：可能在超时时间内出现数据不一致．
- **异步更新缓存**(基于binlog同步机制)：写入Mysql后，将操作写入binlog,然后将binlog的消息推送到Redis，Redis解析后对缓存数据进行更新

#### 16.Redis为什么设计成单线程

- Redis是完全基于内存，内存操作非常快
- 数据结构简单
- 单线程避免上下文切换和竞争．不会有多线程切换以及加锁释放锁等额外性能消耗
- 使用IO复用模型，非阻塞IO

总之，单线程情况下已经很快了，没必要多线程．可以通过开启多个Redis实例来充分利用多核CPU

redis 核心就是 如果我的数据全都在内存里，我单线程的去操作 就是效率最高的，为什么呢，因为多线程的本质就是 CPU 模拟出来多个线程的情况，这种模拟出来的情况就有一个代价，就是上下文的切换，对于一个内存的系统来说，它没有上下文的切换就是效率最高的。redis 用 单个CPU 绑定一块内存的数据，然后针对这块内存的数据进行多次读写的时候，都是在一个CPU上完成的，所以它是单线程处理这个事。在内存的情况下，这个方案就是最佳方案  —— 阿里 沈询

#### 17.Redis热点Key问题

产生原因：

- 用户消费数据远大于生产数据
- 请求分片过于集中，超过Server端性能极限

危害:

- 流量集中，达到物理网卡上限
- 请求过多，缓存失效
- DB击穿，业务雪崩

解决：

- 服务端缓存：在服务端对热点Key进行缓存，并且当Server端拥堵时，Server可以直接返回．但是存在缓存失效，缓存重建，脏读问题
- Redis缓存：备份热key，使用redis集群分担访问压力

key失效时方案：

- 使用锁来限制访问
- 缓存时间用不过期
- 当key要过期时，延长该key时间并更新该Key

#### 18.Redis集群算法

Redis有三种集群方式：主从复制，哨兵模式和集群

- 主从复制

  - 原理：
    - 从服务器连接到主服务器，发送SYNC命令
    - 主服务器接收到SYNC命令后，开始执行BGSAVE生成RDB文件并使用缓冲区记录此后执行的所有写命令
    - 主服务器生成RDB文件后，向从服务器发送快照文件，并在发送期间继续记录被执行的写命令
    - 从服务器收到RDB文件后，载入该快照文件
    - 主服务器发送快照完毕后，开始向从服务器发送缓冲区记录的写命令
    - 从服务器完成对快照的载入，接收来自主服务器缓冲区的写命令(从服务器初始化完成)
    - 主服务器每执行一个写命令就向从服务器发送同样的写命令，从服务器收到后执行该写命令
  - 优点：
    - 主持主从复制，进行读写分离，主服务器负责写命令，从服务器负责处理读操作
    - 分担Master节点的读操作压力
    - 分担Master节点的同步压力，salve节点也可以接受来自其他节点的同步请求
    - 同步方式为非阻塞方式，所以Master节点在同步期间仍然可以接收来自客户端的请求
  - 缺点：
    - 该模式不具有自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失效，需要等待机器重启或者手动修改客户端连接的Redis节点才能恢复
    - 主机宕机可能引起部分数据未同步到从服务器，导致数据的不一致，降低系统可用性
    - 该模式较难支持在线扩容，在线扩容很复杂

- 哨兵模式

  用于监控Redis系统的运行状况：监控主服务器和从服务器是否正常运行； 从服务器出现故障时自动将从服务器转换为主服务器。

  - 工作方式
    - 每个哨兵进程以每秒钟一次的频率向整个集群的主服务器，从服务器以及其他哨兵进程发送一个ping命令
    - 如果一个实例距离最后一次有效回复超过一定时间，则该实例会被哨兵标记为主观下线
    - 如果一个主服务器被标记为主观下线，则监视该主服务器的所欲哨兵进程需要以每秒一次的频率确认主服务器的确进入了主观下线状态
    - 当有足够的哨兵进程在指定时间范围内确认主服务器进入了主观下线状态时，主服务器会被标记为客观下线
    - 在一般情况下，每个哨兵进程以每10秒一次的频率向集群中所有主服务器，从服务器发送INFO命令
    - 当主服务器被哨兵标记为客观下线，哨兵向所有服务器的INFO从10秒一次变为1秒一次
    - 若没有足够数量的哨兵进程同一主服务器下线，主服务器的客观下线状态会移除。若主服务器重新向哨兵进程发送Ping命令的有效回复，则主服务器的主观下线的状态会被移除
  - 优点
    - 基于主从模式，所以主从模式所有优点，哨兵模式都有
    - 主从服务器可以自动切换，系统更健壮，可用性更高
  - 缺点
    - 在线难以扩容，在集群容量达到上限时在线扩容很复杂

- Cluster集群

  哨兵模式可以实现高可用，读写分离。在这种模式下每台Redis服务器存储相同的数据，浪费内存。所以在Redis3.0加入了Cluster模式，实现Redis分布式存储。

  Cluster采用无中心节后，特点如下

  - 所有的节点彼此互联，内部使用二进制协议优化传输速度和带宽
  - 节点的fail通过集群中超过半数节点检测失效时才失效
  - 客户端与Redis节点直连，不需要中间代理层，客户端不需要连接集群所有节点，只需要连接集群中任何一个节点

  Cluster模式通过槽指派方式来实现

  并且每个节点也会具有主从模式来增加健壮性。但是Cluster模式不需要哨兵进程来检测节点是否下线，而是通过Cluster集群中其他节点来监测

































