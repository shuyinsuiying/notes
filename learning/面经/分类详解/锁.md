该部分主要记录Synchronized，volatile两个关键字的底层原理

## synchronized

#### 对象的内存内存布局

在JVM中，对象内存布局中存在三部分，对象头，实例变量，填充数据

- 对象头：包括两部分数据，mark Word和class pointer.

  ![avatar](https://img-blog.csdnimg.cn/20190512092813139.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5NDY4NTcz,size_16,color_FFFFFF,t_70)

  - mark word:存储对象自身的运行数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳．
  - class Pointer:对象指向自己类元数据的指针．虚拟机通过该指针确定该对象属于哪个类的实例

### 实现原理

Monitor:监视器锁，每个对象都有一个monitor,当monitor被占用时对象处于被锁定状态．

> 每个对象都有一个监视器锁，当monitor被占用时处于锁定状态．线程执行monitorenter指令时尝试获取monitor所有权
>
> 1.当monitor进入数为0，线程进入monitor，然后将进入数设置为1，线程为该monitor所有者
>
> 2.线程已经占有该monitor，重进入时，进入数+1
>
> 3.如果其他线程占用monitor，则该线程阻塞直到monitor进入数为0，再重新尝试获取monitor所有权．

> 执行monitorexit的线程必须是Object对应的monitor持有者．每执行一次exit，进入数-1,如果进入数为0线程释放monitor,其他线程可以尝试获取该monitor所有权

monitorenter和monitorexit是成对出现的

**方法的同步**使用的是一个ACC_SYNCHRONIZED标识，进行方法调用时检查是否有该标识，如果有的话，线程需要获取该方法对应的monitor,但是也可以使用这两个指令实现的．

### 优化

jdk1.6以后对synchronized进行了优化，引入了偏向锁，轻量级锁，锁的级别由低到高逐步升级．无锁 －＞偏向锁－＞轻量级锁－＞重量级锁

线程在等待的时候不是直接挂起，而是会自旋一定次数，在自旋过程中尝试获取锁．这样可以避免线程切换开销，提升性能．

**偏向锁**

线程访问同步块并获取锁时，会在**对象头**和**栈帧中的锁记录中**存储锁偏向的线程ID,线程进入和退出同步块时，不需要CAS操作，而是测试对象头中的Mark work是否存储指向自身线程的偏向锁．如果成功表示线程已经获得锁；如果失败，判断该锁是否是偏向锁，如果不是，则使用CAS竞争锁，如果是，则撤销线程的偏向锁，并竞争尝试CAS将对象头的偏向锁指向自己．

**锁膨胀过程**

- 线程在获取对象锁时，先检查对象头中的markword是否为可偏向锁状态，
- 如果是，则检查markword里存储的偏向锁ID是否指向自己，如果是则直接进入同步代码块。否则当前线程会尝试CAS操作去修改对象头中偏向形成ID为本线程的ID。
- 修改失败，当前同步对象存在竞争，等待持有锁的线程到达全局安全点，撤销对象的偏向锁。并检查原持有锁的线程是否已经退出同步代码块。如果是，当前线程尝试CAS将对象的锁记录指向自己。
- 如果原线程为退出同步代码块，锁升级成为轻量级锁，并开始自旋一定次数获取锁(将当前对象头中markword指向自己)，自旋结束后未获取到锁，则锁升级为重量级锁

**三种锁对比**

| 类型     | 优点                                   | 缺点                                   | 适用场景                                   |
| -------- | -------------------------------------- | -------------------------------------- | ------------------------------------------ |
| 偏向锁   | 加锁、解锁不需要额外的资源消耗，效率高 | 如果存在线程竞争，会带来额外的解锁消耗 | 适用只有一个线程访问同步块情景             |
| 轻量级锁 | 竞争的线程不会阻塞，提高程序响应速度   | 如果失败，会自旋消耗CPU                | 针对锁占用时间短，对响应时间比较敏感的情况 |
| 重量级锁 | 线程竞争不适用自旋，不占用CPU          | 线程被阻塞                             | 锁占用时间较长                             |





















