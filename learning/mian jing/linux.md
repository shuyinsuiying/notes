### linux IO模式

对于IO访问，数据会先被拷贝到操作系统内核的缓冲区，然后从缓冲区拷贝到应用程序的地址空间．当一个read操作发生时，它会经历两个阶段：

- 等待数据准备
- 将数据从内核拷贝到进程中

linux系统存在５种网络模式：

- 阻塞I/O

  - 默认情况下所有的socket都是blocking．
  - 当用户调用了recvfrom这个系统调用，内核就开始IO第一阶段：准备数据(对于网络IO，很多数据都需要等待)，该过程需要等待．用户进程这边，整个进程被阻塞直到内核将数据准备好，然后数据会从缓冲区拷贝到用户内存空间，内核返回结果，用户进程解除blocked状态，继续运行

- 非阻塞I/O

  - linux下，通过设置socket可以使其变成为non-blocking.当用户进程发出read操作时，如果内核中数据没有准备好，内核立即返回给进程一个error．用户进程并不需要等待就可以知道结果．之后，用户进程可以去执行其他任务，并定期轮询，直到内核准备好数据返回给进程．

- I/O多路复用

  - 就是我们所说的select/poll/epoll．单内核可以同时处理多个网络连接的IO，基本原理就是func会不断轮询所负责的所有socket,当某个socket有数据到达，就通知用户进程．

  - 当用户进程调用了select，整个进程被阻塞，而同时，内核会监视所有select负责的socket，当任何一个socket中数据准备好了，select就会返回．用户进行在调用read操作，将数据从缓冲区拷贝到用户进程．

  - > IO多路复用特点是通过一种机制一个进程能够同时等待多个文件描述符，这些文件描述符任意一个进入读就绪状态就可以从select()函数返回

  - 好处是单个进程可以同时处理多个网络I/O．系统开销小

  - 应用场景：

    - 服务器需要同时处理多个处于监听状态或者多个连接状态的套接字
    - 服务器需要同时处理多种网络协议的套接字，如同时处理TCP和UDP请求
    - 服务器需要监听多个端口或处理多种服务
    - 服务器需要同时处理用户输入和网络连接

- 信号驱动I/O

  - 允许socket进行信号驱动IO,并注册一个信号处理函数，进程继续运行并不阻塞．当数据准备好时，进程会收到一个sigIO信号，可以在信号处理函数中调用I/O操作函数处理数据．数据从内核拷贝到进程空间过程中，进程被阻塞
- 异步I/O

  - 进程在发起aio_read操作后，立刻去做其他事情，另一方面，内核收到异步调用后，会立刻返回．然后内核会等待数据准备完成后将数据拷贝到用户空间，完成后通知进程，所以，进程可以直接对数据进行处理，不会产生阻塞．

对比：

![avatar](https://img-blog.csdn.net/2018063023500587?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pfcnlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### I/O多路复用的select,poll,epoll

三种方式本质上都是同步I/O，进程自己把数据拷贝到用户空间

**select:**

```c++
int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```

select函数监视的文件描述符分3类．分别是writefds,readfds,exceptfds．调用select函数会阻塞，直到有描述符就绪(有数据可读，可写，except)或者超时．当select函数返回后，可以通过遍历fdset，找到就绪的描述符

**优点：**良好的跨平台性

**缺点**：

- 单进程监视的文件描述符数量存在最大限制，linux上为1024．
- 对socket扫描是线性的，效率较低
- 需要维护一个用来存放大量fd的数据结构，每次调用select，都要把fd_set集合从用户态拷贝到内核态，开销大



poll

```c++
int poll (struct pollfd *fds, unsigned int nfds, int timeout);
```

与select类似，管理多个描述符也是进行轮询，根据描述符状态进行处理．但是poll没有最大文件描述符数量限制(poll基于链表存储)．

缺点：

- 大量的fd被复制到内核空间
- 水平触发，如果通知的fd没有被处理，那么下次poll时还会再次报告该fd．

epoll

内核2.6被提出，基于事件驱动的I/O方式．相对于select来说，epoll没有描述符个数限制，使用一个文件描述符管理多个描述符，将用户关心的文件描述符的时间放在一个内核的实践表中，这样，用户空间与内核空间的copy只需一次．

```c++
int epoll_create(int size);
int epoll_ctl(int epfd,int op, int fd, struct epoll_event *event);
int epoll_wait(int epfd,struct epoll_event *events,int maxevents,int timeout);
```

- int epoll_create:创建一个epoll句柄，size告诉内核监听数目.调用完毕后需要关闭

- epoll_ctl：对指定描述符fd执行op操作

  - --epfd:create返回值，句柄描述符

    --op:表示操作，用三个宏表示：添加／删除／修改 (epoll_CTL_ADD/DEL/MOD)

    --fd：需要监听的fd

    --epoll_event:告诉内核需要监听的事件

- epoll_wait:等待epfd上的i/o事件,最多返回maxevents个事件

epoll能够显著提高程序在大量并发连接中只有少量活跃情况下的系统CPU利用率．原因在于获取事件时，无须遍历整个被监听的描述符集，只要遍历那些被内核I/O事件异步唤醒而加入Ready队列的描述符集合．

**工作模式**

epoll对文件描述符有两种模式：

- LT(level trigger):默认模式，epoll_wait检测到描述符事件发生并将此事通知应用程序，应用可以不立即处理该事件．下次调用时，会再次相应应用程序并通知此事件
- ET(edge trigger):与LT不同，应用程序必须立即处理该事件，否则，下次调用epoll_wait时，不会再次响应应用程序并通知此事件．

**优点**：

- 没有最大并发连接限制，能打开的FD上限远大于1024
- 效率提升，不会随着FD数目增加导致效率下降
- 内存拷贝：利用mmap()文件映射内存加速与内核空间的消息传递．

### 用户态与内核态

在计算机中，存在两类程序，用户程序/系统程序，为了保证系统程序不被用户程序有意破坏，计算机设置了两种状态．

- 内核态：控制计算机硬件资源，并提供上层应用程序运行环境
- 用户态:上层应用的活动空间，程序的执行必须依赖于内核提供的资源

当程序运行在特权级3级上时，该程序运行在用户态．因为这是最低特权级，特权级0运行内核态．用户态不能访问内核态的地址空间．用户态占有的处理机可以被抢占

用户态切换到内核态的三种方式：

- 系统调用(主动)：用户态进程主动要求切换到内核态．用户态进程通过系统调用来申请操作系统提供的服务程序完成工作．如：fork()创建一个新进程．
- 异常：当CPU在执行用户态程序时，发生某些事先不可知异常，会触发由当前运行进程切换到异常处理的内核相关进程中，切换到内核态．如：缺页异常
- 外围设备中断：外围设备完成用户请求操作后，会向CPU发出中断信号，CPU会暂停执行当前程序转而去执行中断信号对应的处理程序．如果当前正在执行的程序是用户态程序，那么转换过程就是用户态到内核态的切换．如硬盘读写完成．

### Linux命令

- 查看CPU: cat /proc/cpuinfo
- 查看内存： 
  - cat /proc/meminfo
  - free命令
- 查看磁盘信息： fdisk -l
- 查看内核/操作系统/CPU信息：uname  -a
- 操作系统版本：  head -n 









































