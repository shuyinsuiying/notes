## 计算机硬件中遇到的一些问题

#### 缓存行伪共享

CPU和主存之间存在三级缓存L1,L2,L3，其中，CPU读取L1大概需要1ns,读取L2需要3ns，读取L3需要15ns，读取主存需要100ns。

缓存cache中存在缓存行，每个缓存行一般来说有64字节，线程在CPU中执行时，每次会去缓存行中读取自己需要的数据，一次读取一整个缓存行，即使该行中其他数据线程不需要。

在多线程运行过程中，存在两个线程读取同一个缓存行的数据，无论数据是否相同，当其中一个线程需要将自己操作的缓存数据写回内存时，所有缓存cache中对该数据的缓存行均置位无效。会重新从内存中读取。那么，操作同一个缓存行的线程会重新读取该缓存行数据，即使该线程操作的数据没有被修改过。

解决方法：

- 缓存行填充

#### 合并写技术

当cpu执行存储指令时，它首先会尝试将数据写到离cpu最近L1cache中，如果此时L1未命中，则会访问下一级缓存。在速度上，L1和cpu速度持平。在L1未命中后，CPU会使用缓冲区将数据写入，成为合并合并写技术。具体做法是Cpu将要写入的数据，写入到合并写缓冲区中。这个缓冲区允许CPU在写入或者读取该缓冲区数据的同时，继续执行其他指令，这就缓解了CPU写数据时性能影响。

​	在后续的指令需要写相同的缓存行时，可以对缓冲区进行性合并。

​	程序在读取已经写入到缓冲区的某些数据时，在读取缓存数据之前会读取缓冲区数据。



#### 磁盘调度算法

常用的磁盘调度算法有4种

- 先来先服务算法：根据磁盘访问请求多的先后顺序进行调度
- 最短询道时间优先算法：每次选择距离磁头最近的磁道，使得每次寻道时间最短。该算法能够获得比较好的吞吐量，但是不能保证平均询道时间最短。并且对于请求的相应时间不是均等的。
- 电梯算法：每次磁头朝一个方向移动，当到达最外面的磁道时，将磁头换向。
- 循环扫描：磁头指朝一个方向移动。到到达最外侧磁道时，磁头立即返回到最里面磁道，然后重新向外扫描磁道。

#### 缓存一致性协议

原因：为了缓解CPU执行速度与内存读取数据速度的不一致性，CPU中引入了高速缓存来存储从内存中读取的数据，以及CPU执行期间需要存储的数据。多核CPU下，存在多个一级缓存，如何保证所有缓存的数据一致性，不让系统数据发生混乱，这里引入了缓存一致性协议。

| 状态                   | 描述                                                         | 监听任务                                                     |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| M(modified)修改        | 该Cache Line有效，数据被修改，和内存中数据不一致，数据只存在于本Cache中 | 缓存行必须时刻监听所有试图读该缓存行相对主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态改为S态之前被延迟操作 |
| E(Exclusize)独享、互斥 | 该Cache Line有效，数据和内存数据一致，数据只存在本Cache中    | 缓存行必须监听其他缓存读取主存中该缓存行操作，一旦有这种操作，该缓存行状态编程S态 |
| S(Shared)共享          | 该Cache Line有效，数据和内存中数据一致，数据存在于很多Cache中 | 缓存行必须监听其他缓存使该缓存行无效或者独享该缓存的请求，并将该缓存行置位无效 |
| I(Invalid)             | 该Cache line无效                                             |                                                              |

**注**：对于M和E状态而言总是精确的，他们在和缓存行真正的状态是一致的，而S态可能是非一致的。因为S态缓存行不可能将自己升级为E状态，即使该缓存行已经是独享该缓存。







































