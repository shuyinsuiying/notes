#### 1. 简要说明进程和线程以及它们的区别

- 进程是具有一定功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源调度和分配的独立单位；

- 线程是进程的实体，是CPU调度和分配的基本单位，它是比进程更小的能独立运行的基本单位；

  对比：

- 调度方面：线程是独立的调度和分派单位，进程是资源的拥有单位

- 并发性：进程间可以并发，一个进程内部多线程也可以并发

- 拥有资源：进程是资源拥有单位，线程访问所隶属的进程资源，并维护与运行相关的资源(栈信息，控制信息等)。

- 系统开销：创建与切换进程需要系统创建/回收PCB，系统资源等，切换也要保存和恢复环境，线程的切换只需要保存和恢复少量寄存器。

- 进程更加健壮，多线程的进程中只要有一个线程死掉，整个进程也会死掉。而进程的崩溃并不会对其他进程造成影响，因为进程有自己独立的地址空间。

- 通信：线程之间的通信更加方便，可以通过全局变量，静态变量等数据进行。进程需要通过其他方式来通信。

#### 1.1 进程与线程的组成

​	Linux系统中进程由以下三部分：

- 进程控制块PCB ：进程存在的唯一标志，用于记录进程状态和其他相关信息的数据结构
- 数据段：又分为3部分：用户栈区，用户数据区(包括用户工作数据和非可重入的程序段)，系统数据区(包括系统变量和对换信息)
- 正文段：可重入区域，能被若干进程所共享

线程由以下部分组成：

- 线程ID
- 指令指针
- 寄存器集合和堆栈



#### 2. 线程同步的方式有哪些

* **互斥量**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，保证公共资源不被多线程同时访问；
* **信号量**：允许同一时刻多线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量；
* **事件**:通过通知的方式来保持多线程同步，以便方便的实现多线程优先级的比较操作。
* **临界区**：通过对线程串行化访问公共资源或一段代码

#### 3. 进程的通信方式有哪些

​	主要有：管道，系统IPC(包括消息队列，信号量，共享存储)，socket

>  管道主要分为：普通管道PIPE，流管道(s_pipe),命名管道(name_pipe)
>
> - 普通管道是一种半双工的通信方式，数据单向流动，并且只能在父子进程间
> - 命名管道是半双工的通信，允许普通进程间通信
> - 信号量是一个计数器，通常作为锁
> - 共享内存是映射一段能被其他进程访问的内存，该内存由一个进程创建，可以被多个进程访问。

#### 4. 关于缓冲区溢出

​	缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。

​	危害：

- 程序崩溃，导致拒绝服务
- 跳转并且执行一段恶意代码

#### 5. 什么是死锁？死锁产生的条件？

​	死锁指两个或以上的进程在执行过程中，由于竞争资源，相互持有对方所需资源而又不释放产生的阻塞现象，若无外力作用，进程会一直阻塞下去。即两个或多个进程无限期的阻塞，相互等待的一种状态。

死锁产生的四个条件：

- 互斥
- 请求与保持
- 非剥夺
- 循环等待

死锁的处理：预防死锁，避免死锁，检测死锁，解除死锁

**预防死锁**：

- 破坏请求与保持条件：进程运行前向系统申请所有需要的资源，若不满足，则不分配资源给进程；
- 破坏非剥夺：进程在无法获得自己所需的资源时，释放自己已经占有的资源
- 破坏循环等待：实现资源有序分配，进程在申请资源时按照既定顺序一次申请资源

#### 6 进程的状态

- 就绪状态：进程获得除处理机以外的所需资源，等待分配处理机资源
- 运行状态：占用处理机资源运行
- 阻塞状态：进程等待某种条件，达到条件之前无法运行

#### 7.分页和分段的区别

- 段是信息的逻辑单位，它根据用户需求划分，对用户可见；页是信息的物理单位，为了管理主存的方便而划分，对用户透明；
- 段大小不固定，由它完成的功能决定，页大小固定，由系统决定;
- 段向用户提供二维地址空间，页向用户提供一维地址空间了
- 段是信息的逻辑单位，便于存储保护和信息共享，页的保护和共享受限。 

#### 8.OS进程调度策略

FCFS(先来先服务)，短作业优先SJF，高相应比优先HRN，时间片轮转，多级反馈

#### 9. 操作系统四个特性

并发，共享，虚拟，异步

#### 10.操作系统主要功能

处理机管理， 内存管理，设备管理，文件管理，提供用户接口

#### 11.用户态与核心态切换的3中方式

- 系统调用
- 异常
- 外围设备的中断

#### 12. 内存的连续分配

- 首次适应算法：空闲分区按照地址递增次序连接，分配时按照顺序查找到能满足要求的第一个空闲分区
- 最佳适应算法：空闲分区按照容量递增连接，分配时按照顺序查找到能满足要求的第一个空闲分区
- 最坏适应算法：与最佳适应算法相反

#### 13.虚拟内存

​	如果一个程序运行时需要的内存空间超过计算机可以提供的实际内存，正常情况下该程序就无法运行。

​	基于**局部性原理**，程序在装入时，可以将程序的一部分装入内存，剩余部分留在外存。在程序的执行过程中，当所访问的信息不在内存时，由OS进行页面置换将所需的部分调入内存。这样系统看起来为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。

​	虚拟存储器特征:多次性，对换性，虚拟性

#### 14.页面置换算法

- 最佳置换算法
- 先进先出置换算法
- 最近最久未使用算法LRU：
- Clock算法
- 改进型Clock算法
- 最少使用算法LFU

#### 15.临界区，冲突解决

**临界区**：每个进程访问**临界资源(**一次仅允许一个进程使用的资源)的那段程序称为临界区．每次仅允许一个进程进入临界区，其他进行等待．

冲突解决：

- 若有若干进程想要访问空闲临界区，一次仅允许一个进程进入
- 任何时候，进入临界区进程不能多余一个，其余要进入临界区进程等待
- 如果进程不能进入临界区，应让出CPU，避免忙等
- 进入临界区进程要在有限的时间内退出

#### 16．进程调度算法

- 先来先服务(FCFS)
- 短作业优先(SJF:short process first):运行时间最短的作业先执行
- 时间片轮转
- 高相应比优先:相应比：(已等待时间＋要求运行时间)/要求运行时间
- 优先权调度算法：按照进程优先权大小调度
- 多级队列：

#### 17.同步IO与异步IO

同步/异步，与**消息的通知机制**有关

阻塞/非阻塞，与**等待消息时状态**有关

**同步**:在发起一个功能调用时，在没有得到返回结果前，该调用不返回

**异步**：在一个异步过程调用发出后，调用者不会等到结果返回，实际的调用完成后，通过状态，通知，回调的形式来通知调用者

**阻塞**：调用返回结果之前，当前线程被挂起．函数只有得到结果之后才会返回．

**非阻塞**：指再不能得到接过之前，函数不会阻塞当前线程，而是立刻返回．

**同步IO和异步IO区别**：数据拷贝的时候进程是否阻塞

**阻塞IO和非阻塞IO区别**:应用程序的调用是否立即返回

**注**：同步调用不是阻塞调用．对同步调用来说，当前线程在没有获得需要的结果时，会去执行其他逻辑，也会主动检查IO是否准备好．



#### 18.用户态和内核态

用户态：非特权状态，进程工作在用户空间下就是用户态，进程能访问的内存空间和对象收到限制．占有的处理机可以被抢占

内核态：特权状态，进程工作在内核空间下就是内核态．能够访问所有的内存和对象，所占有的处理机不能被抢占

切换：

用户态到内核态：系统调用，异常，中断

#### 19.堆和栈的区别

stack:

- 在栈上创建的变量会自动回收
- 相比堆来说，栈的速度快
- 使用数据结构中的栈实现
- 存储局部数据，返回地址，用作参数传递
- 栈调用过多时会导致栈溢出
- 栈上的数据可以直接访问(不一定非要用指针访问)
- 程序启动时决定栈的容量上限

heap:

- 堆上的变量必须手动释放，不存在作用域的问题
- 分配速度慢于栈
- 通过程序按需分配
- 分配和释放会造成内存碎片
- 申请缓冲区过大时，会导致申请失败
- 存在内存泄漏

#### 20.进程与线程，协程之间的区别

进程与线程之间的区别：

- 线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间
- 资源拥有：进程是资源拥有的基本单位，线程是程序调度执行的基本单位
- 二者均可并发

线程与协程的区别：

- 一个线程可以有多个协程，一个进程也可以单独拥有多个协程
- 协程能够保留上一次调用状态，能够快速恢复执行
- 线程是抢占式，协程非抢占式，协程之间的切换是由用户决定的
- 线程是协程的资源，协程需要线程来承载运行
- 协程的执行是原子性的，不会出现执行到一半的代码片段被中断的情况，不需要加锁

三者之间的比较：

| -        | 进程                         | 线程              | 协程                   |
| -------- | ---------------------------- | ----------------- | ---------------------- |
| 切换者   | 操作系统                     | 操作系统          | 用户                   |
| 切换时机 | 根据操作系统内部策略         | 同左              | 用户自己决定           |
| 切换内容 | 页全局目录/内核栈/硬件上下文 | 内核栈/硬件上下文 | 硬件上下文             |
| 内容保存 | 存于内核                     | 存于内核          | 存于用户栈/堆          |
| 切换过程 | 用户态-内核态-用户态         | 同左              | 用户态(没有陷入内核态) |
| 切换效率 | 低                           | 中                | 高                     |

线程内协程是串行执行的，不能利用多核.

协程是一类特殊的函数

#### 21.虚拟内存

**定义**：基于局部性原理，程序在装入运行时，可以将程序的一部分装入内存，而将其他需要的内容驻留在外存，程序可以启动运行．程序在运行过程中，需要的数据不在内存中时，由操作系统进行页面调度，将需要的内容置换进内存，并且将不需要的页换出．这样，系统好像给程序提供了一个比物理实际存储空间大得多的存储器，称为虚拟存储器．实际上该存储器并不存在．

虚拟内存由底层硬件和操作系统两者结合实现．主要提供三个能力：

- 给所有进程提供一致的地址空间，每个进程都认为自己独占单机系统的存储资源，简化内存管理
- 保护每个进程的地址空间不被其他进程破坏
- 将主存看作是存储在磁盘空间上的地址空间的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间传送数据

**虚拟地址和物理地址**

每个进程使用的都是虚拟地址，进程看到的都是同样的虚拟地址空间．CPU执行指令时取实际物理地址分为以下几步：

- 将进程指令使用的虚拟地址通过MMU转换成物理地址
- 把物理地址映射到高速缓存的缓存行
- 如果高速缓存命中就返回
- 如果不命中，产生缺页中断

操作系统会将数据分割成很多页，每次换入换出以页为最小单位．页的大小通常在4k-2M之间．

对于CPU来说，其目标是物理内存，使用高速缓存做物理内存的缓存

对于虚拟内存来说，目标是磁盘空间，使用物理内存做磁盘的缓存

虚拟页的集合分为3个不相交的子集：

- 未分配的页，没有任何数据和这些页关联，不占用任何磁盘空间
- 缓存的页，已经分配的页，并且已经缓存在具体的物理页中
- 未缓存的页，已经为磁盘分配了虚拟页，但是没有缓存到具体的物理页中

虚拟存储系统需要判断一个虚拟页面是否在主存中，如果命中，则直接找打对应的物理页，如果不命中，操作系统需要去磁盘找到对应的页，并根据替换策略从内存中选择一个页与该页进行置换．

**页表**

页表存放在主存中，每个进程单独维护一个页表．管理虚拟内存页与物理内存页的映射和缓存状态的数据结构．

**虚拟地址工作原理**

对于进程来说，使用的都是虚拟地址，每个进程维护一个单独的页表．页表中

- 数组的索引号，代表虚拟页号
- 数组的值
  - 若为null，表示未映射的页
  - 若非null,第一位表示有效位，１代表缓存的页，0代表未缓存的页
- 其余位表示缓存到的物理页号

进程执行时，当需要访问虚拟地址中存放内容时，步骤：

- CPU会先找到虚拟地址所在的虚拟页，根据页表找判断页表中目标位置有效位，若为1则命中，存内存中对应地址找到需要数据，返回
- 若为0，产生缺页异常，由内核进行缺页调度
- 缺页调度执行完后，重新执行，发现缓存命中，返回
- 将命中数据放入到CPU高速内存中，CPU继续执行

问题：

- 缺页调度时，如果程序局部性不好，会产生**缓存颠簸**
- 一级页表占用空间较大，一般会使用多级页表

**优点**：

- 虚拟内存管理可以控制物理内存的访问权限
- 提高内存利用率
- 隔离各个用户进程
- 为内存的分配和释放带来方便：虚拟内存不需要内存连续的地址



#### 22.虚拟内存(王道)

在内存管理策略中目标是为了同时将多个进程保存在内存中，以便允许进行多道程序设计，都具有以下两个特征：

- 一次性：作业必须一次性装入内存，才能开始运行．问题：
  - 当作业无法全部装入内存时，作业无法运行
  - 当大量作业要求运行时，内存不足会使得只有少数作业先运行
- 驻留性：作业被装入内存后，一直到作业运行结束之前都驻留在内存中，不会被换出．运行中的进程可能因为等待IO而被阻塞，长期处于等待状态．

**局部性原理**

- 时间局部性：程序的某条指令一旦执行，不久后该指令可能再次执行，数据被访问过，不久后可能再次被访问．产生时间局部性原因为程序中存在大量的循环操作．
- 空间局部性：一旦程序访问某单元，不久后，其附近的单元也可能被访问．因为指令通常是顺序存放，顺序执行的．

**虚拟存储器定义和特征**

基于局部性原理，在程序装入时，将程序的一部分装入内存，而其余部分放在外存，就可以启动程序运行．在程序执行过程中，当所访问的信息不存在时，操作系统将所需要的部分装入内存，再执行程序．另一方面，操作系统将内存中暂时不用的部分换出到外存以腾出空间．这样，系统好像为用户提供了一个比实际内存空间大得多的存储器，称为虚拟存储器．特征如下：

- 多次性：无须在作业运行时一次性的装入内存，而被允许分成多次调入内存运行．
- 对换性：无需在作业运行时一直常驻内存，而允许在作业运行过程中，进行换入换出
- 虚拟性：从逻辑上扩充存储容量，使用户看到的内存容量大于实际的存储容量．

**虚拟内存实现**

- 请求分页存储管理

  > 建立在基本分页系统基础上，为了支持虚拟存储器功能而增加了请求调页功能和虚拟置换功能．在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可以启动程序运行．在程序执行过程中，所访问的页面不存在内存中时，通过调页功能将其调入．同时可以通过置换功能将暂时不用的页面换出到外存上．

- 请求分段存储管理

- 段页式存储管理

**硬件支持**

- 一定容量的内存和外存

- 页表机制

  页表项：

  | 页号 | 物理块号 | 状态位P              | 访问字段A              | 修改位M                    | 外存地址             |
  | ---- | -------- | -------------------- | ---------------------- | -------------------------- | -------------------- |
  |      |          | 指示该页是否调入内存 | 该页一段时间内访问次数 | 标识该页换入后是否被修改过 | 该页存在于外存的地址 |

- 中断机构

  > 请求缺页系统中，当所要访问的内存不存在时，产生一个缺页中断，请求操作系统将所缺的页调入内存，此时将缺页的进程阻塞，若内存中有空闲块，则分配一个块，将调入的页装入该块，并修改页表中的相应页表项，若此时没有空闲块，则淘汰某页．

- 地址变换机构

  > 进行地址变换时，先找到要访问的页，修改页表中的访问位，然后利用页表给出的物理块号和页内地址形成物理地址
  >
  > 若未找到该页的页表项，则去内存中查找页表，在对比页表项中的状态位P,查看该页是否已经装入内存，未调入就产生缺页中断，请求从外存中把该页调入内存．

**页面置换算法**

- 最佳置换算法：选择后续永远不会被使用的页面淘汰，或者是最长时间内不再被访问的页面淘汰，以便保证最低的缺页率．

  - 该算法通常用来评价其他算法．

- 先进先出算法

  优先淘汰最早进入内存的页．该算法实现简单，只需要调入内存的页面根据先后次序链接成队列，设置一个指针指向最早的页面．但该算法与实际运行时规律不符，因为有些页面会被经常访问．

- 最近最久未使用（LRU）置换算法

  选择最近最长时间未被访问的页面淘汰．

- 时钟置换算法

  简单时钟置换算法给每帧关联一个附加位，称使用位．当页被初次装入内存时，将该位置1;当该页随后再次被访问到时，使用位也置为1; 当某页被替换时，该指针被设置指向当前缓冲区(缓冲区为循环缓冲区)下一帧．每当遇到一个使用位为1的帧时，系统将该位置为0；如果所有位都为0，则选择第一个帧替换；若所有帧都为１,则扫描一周，所有的使用位置为0；替换最开始那个页．

  每一帧处于以下四种状态之一：

  - 最近未被使用，也未被修改(u=0,m=0)
  - 最近被访问，未被修改(u=1,m=0)
  - 最近未被访问，被修改(u=0.m=1)
  - 最近被使用，被修改(u=1,m=1)

  算法执行步骤：

  - 指针从当前位置开始，扫描缓冲区，查找最近未被使用，也未被修改(u=0,m=0)帧，并替换
  - 如果失败，重新扫描，查找(u=0,m=1)的帧，选择遇到第一个该帧并替换，扫描过程中，将每一个扫描的帧使用位置为0
  - 如果失败，指针指向初始位置，替换初始位置的帧

**页面调入时机**

- 预调页策略：基于局部性原理，一次性装入若干相邻的页可能会比一次调入一个页更高效．该策略适用于程序启动时首次调入
- 请求调页策略：进程在运行中需要访问的页不存在内存而提出请求，系统将所需页面调入内存，该策略调入的页一定已被访问．缺点是每次只调入一个页

**调入位置**

请求分页系统外存分为两部分，用于存放文件的文件区和存放对换页面的对换区．对换区采用连续分配的方式，文件区采用离散分配的方式．

- 系统拥有足够的对换空间：可以全部从对换区调入所需要的页面，提高调页速度．为此，进程运行前，需要将与该进程有关的文件从文件区复制到对换区．
- 系统缺少足够的对换区空间：不会被修改的文件从文件区调入，可能被修改的部分，在换出时将该部分放到对换区．
- unix方式:与进程有关的文件都放在文件区，未运行过的页面都应从文件区调入，运行过的页面被换出时放在对换区，下次调入时从对换区调入．

**抖动**：刚刚换出的页面马上要换入内存，刚刚换入的页面马上要换出内存．频繁的页面调度称为抖动．

**地址翻译**

略





















`