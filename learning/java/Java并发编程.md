## 第一章 并发编程的挑战

### 1.1 上下文切换

#### 1.1.3 如何减少上下文切换

- **无锁并发编程**：多线程竞争锁时，会导致上下文切换。多线程处理数据时，应当避免使用锁；
- **CAS算法**：java的atomic包使用CAS算法来更新数据，不需要加锁；
- **使用最少的线程**：避免创建不必要的线程；
- **协程**：在单线程里实现多任务调度，并在单线程里维持多任务间切换



---

---



## 第二章 java并发机制的底层实现原理

### 2.1 volatile的应用

 	volatile保证了共享变量的可见性。当一个线程修改一个共享变量时，另一个线程能够读取到修改后的值。

> Java语言规范第三版对volatile定义如下：java编程语言允许线程访问共享变量，为了确保共享变量能够被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量

| 术语       |                           术语描述                           |
| ---------- | :----------------------------------------------------------: |
| 内存屏障   |         一组处理器指令，用于实现对内存操作的顺序限制         |
| 缓冲行     | CPU高速缓存中可以分配的最小存储单位。处理器填写缓存行时会加载整个缓存行。 |
| 原子操作   |                  不可中断的一个或一系列操作                  |
| 缓存行填充 | 当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个高速缓存行到适当缓存(L1,L2,L3) |
| 缓存命中   | 如果高速缓存行填充操作的内存位置仍是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存中读取 |
| 写命中     | 当处理器将操作数写回到缓冲内存的区域时，它会首先检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，处理器会去将操作数写到缓存，而不是写到内存 |
| 写缺失     |           一个有效的缓存行被写入到不存在的内存区域           |

​	volatile实现的两条原则：

- Lock前缀指令会引起处理器缓存写到内存
- 一个处理器的缓存写回到内存会导致其他处理器的缓存无效

#### 2.Volatile优化

​	追加字节，将共享变量追加到64字节一般可以提高性能；

> 由于现在许多处理器的高速缓存行是64字节带宽，填充后会使得一个缓存行只有一个共享变量，当处理器修改该变量时，不会影响其他共享变量的使用

> 不适用情况：
>
> - 缓存行非64字节宽的处理器
> - 共享变量不会被频繁读写

### 2.2 sychronized的实现原理与应用

​	对象锁情况：

- 对于普通方法，锁是当前实例对象
- 对于静态同步方法，锁是当前类的Class对象
- 对于同步方法块，锁是Sychronized括号里配置的对象

> JVM规范中Sychronized在JVM中实现，Jvm通过进入和退出Monitor对象来实现方法同步和代码块同步。代码块同步使用monitorenter和monitorexit指令实现，而方法同步使用另一种方式实现。但方法同步也可以使用这两个指令实现

>monitor指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束和异常处，JVM要保证每个monitorenter有对应的monitorexit配对。任何对象都有monitor相关联。当一个monitor被持有后，对象被锁定

#### 2.2.1 JAVA对象头

​	sychronized使用锁放在对象头里。如果对象是数组类型，虚拟机使用3字节宽存储对象头(额外1字节存储数组长度)，否则，使用2字节存储对象头

#### 2.2.2 锁的升级与对比

​	javaSE1.6为了减少获得锁，释放锁带来的性能消耗，引入了**偏向锁**和**轻量级锁**，锁有4种状态，级别由低到高：**无锁状态，偏向锁状态，轻量级锁状态，重量级锁状态**。锁升级后不能降级.

​	**1.偏向锁**

​	在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当线程访问同步块并获得锁时，会在对象头和栈帧的锁记录里存储偏向锁线程ID，以后对该线程在进入和退出同步块不需要进行CAS操作来加锁和解锁，只测试一下对象头的mark Word是否存储这指向该线程的偏向锁。如果测试失败，则检查mark word的偏向锁标志是否为1(表示当前是偏向锁)，如果没有设置，则使用CAS竞争锁。如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

​	**撤销偏向锁**：偏向锁使用出现竞争时才释放锁的机制，当其它线程竞争偏向锁时，持有偏向锁的线程才会释放锁。撤销锁时，需要等待全局安全点。首先暂停拥有偏向锁的线程，然后检查其是否存活，若该线程不处于活动状态，则将对象头设置成无锁状态。若该线程还处于活跃状态，则遍历偏向锁线程对象的锁记录，栈中锁记录和对象头的mark word要么重新偏向于其他线程，要么获取到无锁状态或者标记对象不适合作为偏向锁。最后唤醒暂停的线程

![avatar](http://ifeve.com/wp-content/uploads/2012/10/%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80.png)

​	关闭偏向锁：jvm参数：-XX:-UseBiasedLocking=false关闭偏向锁

​	**2. 轻量级锁**

​	**轻量级锁加锁**：线程在执行同步块之前，JVM会在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的mark word复制到锁记录中。然后线程尝试使用CAS算法将mark word 替换为指向锁记录的指针，如果成功，当前线程获得锁。如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。

​	**轻量级锁解锁**：使用原子的CAS操作将Displaced Mark Word替换到对象头，如果成功，表示没有竞争发生。如果失败，当前存在竞争，锁会膨胀成重量级锁。

​	由于自旋会消耗CPU，为了避免无用的自旋，一旦锁升级成为重量级锁，则不会轻易恢复到轻量级锁状态。当锁处于该状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁后会唤醒这些线程，被唤醒的线程会进行新一轮的争夺。

​	3.锁的优缺点对比

| 锁       | 优点                                                         | 缺点                                          | 适用场景                           |
| -------- | ------------------------------------------------------------ | --------------------------------------------- | ---------------------------------- |
| 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同不方法相比仅存在纳秒级差距 | 如果线程间存在锁竞争，会带来额外的锁撤销消耗  | 适用于只有一个线程访问的同步块场景 |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度                     | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU | 追求响应时间，同步块执行速度非常快 |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                              | 线程阻塞，响应时间缓慢                        | 追求吞吐量，同步块执行时间较长     |



### 2.3 原子操作实现的原理

#### 	2.处理器如何实现原子操作

​	**使用总线锁保证原子性**

​	如果多个处理器同时对共享变量进行读写操作，共享变量就会被多个处理器同时操作。处理器使用总线锁来解决该问题。所谓总线锁是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器请求会被阻塞住，该处理器可以独占共享内存。

​	**使用缓存锁保证原子性**

​	同一时刻，只需要保证对某个内存地址的操作是原子性即可。但总线锁会把CPU和内存之间的通信锁住，使得锁住期间其他的处理器不能够操作内存地址的数据，所以总线锁的开销较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。

​	频繁使用的内存会缓存在处理器的L1,L2,L3高速缓存里，原子操作就可以直接在处理器的内部缓存中进行，并不需要声明总线锁。

​	**缓存锁定**：内存区域如果被缓存在处理器的缓存行中，并且在LOCK操作期间被锁定，那么当它执行锁操作写回到内存时，处理器不在总线上声明LOCK#信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性会阻止同时修改有俩个以上处理器缓存的内存区域，当其他处理器回写已经被锁定的缓存行时，会使缓存行无效。

​	两种情况下处理器不会使用缓存锁定：

- 操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，处理器使用总线锁定。
- 有些处理器不支持缓存锁定。



#### 3.CAS实现原子操作的三大问题

CAS(CompareAndSwap)比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。

CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。

- ABA问题：由于CAS在操作值的时候，检查值是否发生变化，如果没有变化则更新。但是一个值原来是A，变成了B，又变回A，CAS检查时便检查不出来，但实际值发生了变化。解决思路：使用版本号，每次变量更新前将版本号+1。

- 循环时间长开销大：自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。

  > 如果JVM能支持处理器提供的pause指令，会提升部分效率。pause指令有两个作用：
  >
  > - 延迟流水线执行指令，使CPU不会消耗过多的执行资源
  > - 避免在退出循环时因内存顺序冲突而引起CPU流水线被清空，提高CPU执行效率。

- 只能保证一个共享变量的原子操作：对于多共享变量操作时，循环CAS无法保证操作的原子性。此时可以用锁。或者把多个共享变量合并成一个共享变量来操作。多个变量可以放在一个对象里执行CAS操作

#### 4.JAVA实现原子操作的方式

- 使用循环CAS实现原子操作
- 通过锁机制来实现原子操作



---

---



## 第三章 Java内存模型

### 3.1 Java内存模型的基础

#### 3.1.1 并发编程模型的两个关键问题

- 线程间如何通信：线程以何种机制来交换信息。

  方式：共享内存和消息传递

  - 共享内存：线程间具有共享的公共状态，通过写-读内存中的公共状态进行隐式通信

- 线程间如何同步：用于控制不同线程间操作发生相对顺序的机制。

  - 在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或者某段代码在线程间互斥执行。
  - 在消息传递的并发模型里，消息发送必须在接收之前，同步是隐式执行的。

  java并发采用共享内存模型，线程之间的通信总是隐式进行，通信对程序员完全透明。

#### 3.1.2 Java内存模型的抽象结构

​	java中所有实例域，静态域和数组元素都存储在堆内存中，堆内存在线程间共享。局部变量，方法定义参数和异常处理器参数不会在线程间共享，它们不会有内存可见性问题，也不受内存模型影响。

​	java线程间通信有JVM控制，从抽象角度看，JVM定义了线程和主内存间的抽象关系：线程间的共享变量在主内存中，每个线程都有一个本地内存，储存先以读/写共享变量的副本。**本地内存是抽象概念，实际并不存在**。

> 线程A和线程B要通信必须经历下面两个步骤：
>
> - 线程A把本地内存更新过的变量刷新到主内存去
> - 线程B从主内存读取线程A更新过的变量

#### 3.1.3 从源代码到指令序列的重排序

​	重排序分3种：

- 编译器优化的重排序

- 指令集并行的重排序

- 内存系统的重排序

  后面两种属于处理器重排序。这些重排序可能引起线程程序出现内存可见性问题。这些重排序会引起多线程程序出现内存可见性问题。

  > 对于 编译器，JVN编译器重排序会进制特定类型的编译器重排序。
  >
  > 对于处理器，JVM会要求java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型处理器重排序。

#### 3.1.4 并发编程模型的分类

​	处理器的写缓冲区可以保证指令流水线持续运行，避免向内存写数据带来的延迟。同时，通过批处理方式刷新写缓冲区，合并写缓冲区中对同一内存地址的多次写，减少对内存总线的占用。

​	处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写顺序一致。

#### 3.1.5 happens-before简介

​	JVM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作间必须存在happens-before关系。

> 程序顺序规则：一个线程中的每一个操作，happens-before于该线程的任意后续操作；
>
> 监视器锁规则：对于一个锁的解锁，happens-before于随后对这个锁的加锁。
>
> volatile规则：对一个volatile域的写，happens-before于后续对该volatile的读
>
> 传递性：

> 两个操作间具有happens-before关系，并不意味着前一个操作必须在后一个操作前执行，仅要求前一个操作对后一个操作可见且前一个操作按顺序排在第二个操作之前。

### 3.2 重排序

​	为了优化程序性能而对指令序列进行重排序。

#### 3.2.1 数据依赖性

​	如果两个操作访问同一个变量，且两个操作中有一个写操作，此时这两个操作存在数据依赖性。

> 编译器和处理器不会改变存在数据依赖关系的两个操作的顺序。
>
> 这里说的数据依赖性仅针对单处理器中执行的指令序列和单线程中执行的操作。不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。

#### 3.2.2 as-if-serial 语义

​	不管怎么重排序，程序的执行结果不能被改变。编译器，runtime和处理器都必须遵循as-if-serial语义。

#### 3.2.3 程序顺序规则

​	程序逻辑中如果：

```
double pi=3.14; //A
double r = 1.0; //B
double area = pi*r*r //C
```

​	按照程序顺序，A happens-before B，但实际执行时B可以在A前面执行 ；JMM对与B在A之前执行的顺序判定其并不非法，并允许这种重排序。

> 单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序执行的结果。

### 3.3 顺序一致性

​	JMM对正确同步的多线程程序的内存一致性做了如下保证:

​	如果程序是正确同步的，程序的执行将具有顺序一致性——即程序的执行结果与该程序在**顺序一致性内存模型**中的执行结果相同。

#### 3.3.2 顺序一致性内存模型

​	理想化的理论参考模型，为程序员提供极强的内存可见性保证。

> 顺序一致性内存模型有两大特性：
>
> 一个线程的所有操作都必须按照程序的顺序来执行;
>
> (不管是否同步)所有的线程只能看到一个单一的操作执行顺序。该模型中，每个操作都必须原子执行且对所有线程可见。

> JMM不具有该保证。未同步程序在JMM中不但整体执行顺序是无序的，而且线程之间看到的操作执行顺序也可能不一致。例如：当前线程执行操作后未将结果刷新到主存，其他线程看不到该操作的结果，会认为该操作没有发生。此时，当前线程与其他线程看到的执行顺序不一致。

#### 3.3.3 同步程序的顺序一致性结果

​	程序一致性模型中，所有的操作都按照程序的顺序串行执行。在JMM中，临界区内的代码可以重排序。

> JMM实现的基本方针为：在不改变程序执行结果的前提下，尽可能的为编译器和处理器优化提供方便。

#### 3.3.4 未同步程序的执行特性

未同步程序在两个模型中执行特性有如下差异：

- 顺序一致性保证单线程内的操作会按照程序的顺序执行，而JMM不保证单线程内的操作会按照程序的顺序执行(临界区内指令重排序)；
- 顺序一致性保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的执行顺序；
- JMM不保证对64位的float和double型变量写操作具有原子性（与总线的工作机制相关），而顺序一致性保证对所有的内存读/写操作都具有原子性。

> 注：JSR-133之前的旧内存模型中，一个64位的变量读/写操作都可以被拆分为32位的读/写操作来执行。从JSR-133(JDK1.5)开始，仅允许将写操作拆开，读操作具有原子性。

### 3.4 volatile变量

#### 3.4.1 volatile特性

volatile特性：

- 可见性。对一个volatile变量的读，总是能看到(任意线程)对该volatile变量的最后写入
- 原子性。对任意**单个变量**的读/写具有原子性，但是类似于volatile++这种复合操作不具有原子性。

volatile读的内存语义：当读取一个volatile变量时，JMM会把该线程对应的本地内存置为无效，去主内存读取共享变量

​								volatile重排序规则表

| 能否重排序 |           |            |            |
| ---------- | |
| 第一个操作 | 普通读/写 | volatile读 | volatile写 |
| 普通读/写  |           |            | NO         |
| volatile读 | NO        | NO         | NO         |
| volatile写 |           | NO         | NO         |

由上表可以看出，当第二个操作是volatile写时，不能重排序；确保volatile写之前的操作不会被排序到volatile写之后；

第一个操作是volatile读时，不能重排序；

第一个操作是volatile写，第二个操作是volatile读，不能重排序。

通过严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读与锁的释放-获取具有相同的内存语义。

volatile仅保证对单个volatile变量的读/写具有原子性，而锁的互斥执行特性确保对整个临界区代码的执行具有原子性。功能上，锁比volatile更强大；volatile具有可伸缩性与执行性能的优势。

### 3.5 锁的内存语义

当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主存中去。

当线程获取锁时，JMM会把该线程对应的本地内存置为无效，从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。

对于公平锁与非公平锁的内存语义：

- 公平锁与非公平锁释放时，最后都要写一个volatile变量state; 
- 公平锁获取时，会去读volatile变量。
- 非公平锁获取时，首先会用CAS更新volatile变量，该操作同时具有volatile读和写的内存语义。

从ReentrantLock分析看出，锁释放-获取的内存语义实现至少有一下两种方式(锁在内存中的实现方式)：

- 利用volatile变量的写-读具有的内存语义
- 利用CAS所附带的volatile读和volatile写的内存语义

### 3.6 final 域的内存语义

#### 3.6.1 final域的重排序规则

对于final域，编译器和处理器遵守两个重排序规则：

- 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序；
- 初次读一个包含final域对象的引用，与随后初次读这个final域，这两个操作间不能重排序。

简而言之，对final修饰的数据进行调用时，必须等数据初始化完毕才可以操作，此时，禁止指令重排序。

#### 3.6.4 final域为引用类型

对于final域为一个引用类型(例如：final int[] array)，在构造函数内对一个final引用对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，两个操作之间不能重排序。

#### 3.7.2 happens-before定义

JSR-133对happens-before关系定义如下：

- 如果一个操作happens-before另一个操作，那么第一个操作的执行结果对第二个操作可见，并且第一个操作执行顺序排在第二个操作之前。
- 两个操作之间存在happens-before关系，只要重排序后的结果与原来按照规则来执行的结果一致，这种重排序并不非法，JMM允许该重排序。

happens-before语义本质上和as-is-serial语义一回事。

### 3.8 双重检查锁定与延迟初始化

java多线程程序中，有时候需要采用延迟初始化来降低初始化类和创建对象的开销。双重锁定检查是常见的延迟初始化技术，但是它是一种**错误的用法**。

#### 3.8.1 双重检查锁定的由来

```java
public class DoubleCheckLocking{
    private static Instance instance;
    public static Instance getInstance() {
        if(instance == null) {							//第一次检查
            synchronized (DoubleCheckLocking.class) {
                if(instance == null)					//第二次检查
                    instance = new Instance();			//问题根源
            }
        }
        return instance;
    }
}
```

上述代码中对于该类的初始化做了两次检查，以用于**降低同步开销**。其错误根源在于，多线程访问时，线程A在进行instance初始化时，线程B可能看到的初始化操作未完成而去错误的调用，其原因是由于指令重排序造成。

创建一个对象的操作可以分为以下三步：

```
memory = allocate();		//分配内存空间
ctorInstance = memory;		//初始化对象
instance = memory;			//设置instance指向建立对象的地址
```

在第二步和第三步，可能发生指令重排序，使得instance看起来指向了一个实际存在的地址，实际上尚未被初始化。

解决方案：

- 将instance变量设置为volatile属性，在多线程环境下，创建对象的指令重排序第2步和第3步会被禁止。
- 基于类初始化的解决方案，可以将共享变量放到类初始化阶段进行，设置静态属性

> 根据java语言规范，首次发生下列任意一种情况时，类或者接口类型T立即被初始化：
>
> - T是一个类，并且一个T类型的实例被创建
> - T是一个类，且T中声明的一个静态方法被调用
> - T中声明的一个静态字段被赋值
> - T中声明的一个静态字段被使用，并且这个字段不是一个常量字段
> - T是一个顶级类，并且一个断言语句嵌套在T内部被执行

java语言规定，对于每一个类或者接口C，都有一个唯一的初始化锁LC与之对应。从C到LC的映射，由JVM自由实现，JVM在类初始化时会获取该初始化锁，并且每个线程至少获取一次锁来保证该类已经被初始化过。

java初始化一个类或接口的处理过程如下：

- 通过在Class对象上同步，来控制类或者接口的初始化。这个获取锁的线程会一直等待，直到能够获取到该初始化锁。线程A第一个获取到初始化时，将锁状态state设置为initializing。
- 线程A执行类的初始化，线程B获取初始化锁，发现状态为initializing，释放锁并等待
- 线程A对类初始化完成后，获取类的初始化锁，并修改状态为initialized，释放锁，唤醒所有等待线程
- 线程B结束类的初始化工作
- 线程C执行类的初始化操作(获取锁，读到锁状态为initialized，释放锁，结束初始化)



***

---



## 第四章 Java并发编程基础

### 4.1 线程简介

​	线程是现代操作系统调度的最小单位，也叫轻量级进程，在一个进程里可以创建多个线程，这些线程拥有各自的计数器，堆栈，局部变量等属性，并且能够访问共享的内存变量。

使用多线程原因：

- 更多的处理器核心
- 更快的响应时间
- 更好的编程模型

线程优先级有时候没有意义，某些操作系统会将java线程优先级设置为同样的等级。

线程状态：线程在运行的生命周期中，存在6中状态：

| 状态名称     | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| New          | 初始状态，线程被构建，但未调用start方法                      |
| Runnable     | 运行状态，Java线程将操作系统中的就绪和运行两种状态称作运“运行态” |
| Blocked      | 阻塞状态，标识线程阻塞于锁                                   |
| Waiting      | 等待状态，表示该线程需要等待其他线程作出一些特定动作         |
| Time_Waiting | 超时等待状态，不同于Waiting,它是可以在指定的时间自行返回的   |
| Terminated   | 终止状态，表示该线程已经执行完毕                             |

>  Daemon线程：Daemon线程是一种支持性线程。主要被用作程序中后台调度以及支持性工作。当一个Java虚拟机中不存在非Daemon线程时，虚拟机将会退出。。
>
> Daemon线程属性需要在线程启动前设置，不能在启动后设置。
>
> Daemon线程语句块中的finally语句不一定被执行，因此，不能够依靠finally块语句来确保执行关闭或者资源清理逻辑。

线程的suspend(),stop()和resume()方法不建议使用，suspend()睡眠时不会释放已经占有的资源，容易引发死锁。stop（）在终结一个线程时不保证线程的资源被正常释放。

### 4.3 线程间通信

volatile和synchronized关键字；

等待/通知机制

管道输入/输出流

Thread.join(): 线程A调用threa.Join()是指，线程A等待被调用的线程终止后，才从thread.join()返回。

ThreadLocal;



---

***



## 第五章 Java中的锁

### 5.1 Lock接口

java1.5之后，并发包中新增了Lock接口来实现锁功能，提供了与synchronized类似的功能，只是在使用时需要显式的获取锁和释放锁。以牺牲隐式方式的便捷性来拥有可操作性，可中断性。

> 注：不要将锁的获取写在try块中，因为在锁的获取中发生异常，会直接执行finally的锁的释放(此时还未获取到锁)，会导致锁的无故释放。

Lock接口提供synchronized关键字不具有的主要特性：

| 特性               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| 尝试非阻塞地获取锁 | 当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁 |
| 能被中断的获取锁   | 获取到的锁能够相应中断，当获取到的锁的线程被中断时，中断异常被抛出同时锁被释放 |
| 超时获取锁         | 在指定的截止日期之前获取锁，如果截止时间到了还未获取锁，则返回 |

### 5.2　队列同步器

用于构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列完成资源获取线程的排队工作。

同步器主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态。需要使用同步器提供的３个方法(Getstate(),setState()和compareAndSetState())来进行操作，因为他们能够保证状态的改变是安全的。

#### 5.2.2　队列同步器的实现

实现包括：同步队列，独占式同步状态获取与释放、共享式同步状态获取与释放、超时获取同步状态。

##### 1.同步队列

同步器依赖内部的同步队列(一个FIFO的双向队列)来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态信息构造成一个节点并将其加入同步队列，同时阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。

![avatar](https://img-blog.csdn.net/20160816191536361?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)





>  同步器使用CAS操作来设置尾节点以保证线程安全，它需要传递当前线程"认为"的尾节点和当前节点，设置成功后，当前节点与尾节点相关联。
>
>  同步队列遵循FIFO，首节点是获取同步状态成功的节点，首
>
>  节点的线程在释放同步状态时，将会唤醒后继节点，后继节点在获取同步状态成功时将自己设置成首节点。
>
>  设置首节点是通过获取同步状态成功的线程来完成，由于只有一个线程能够获取到同步状态，所以设置首节点时不需要使用CAS操作来保证。

##### ２. 独占式同步状态获取与释放

通过调用同步器的acquire方法获取同步状态。该方法对中断不敏感。线程获取同步状态失败后会进入同步队列，后续对线程进行中断操作时，线程不会从同步队列移出。

该方法代码清单如下：

```java
public final void acquire(int arg) {
    if（！tryAcquire(arg)&&
        acquireQueued(addWaiter(Node.EXCLUSIVE,arg))
        selfInterrupt();
}
```

> 上述代码主要逻辑是:首先调用自定义同步器实现的tryAcquire(int arg)方法，该方法保证线程安全的获取同步状态，如果获取同步状态失败，则构造同步节点(独占式Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态)并通过addWaiter()方法将该节点加入到同步队列尾部，最后调用acquire(Node,arg)方法，使得节点以死循环的方式获取同步状态。如果获取不到则阻塞节点中的线程，被阻塞线程的唤醒通过前驱节点的出队或阻塞线程被中断来实现。
>
> 前驱节点出队后，队列中所有阻塞节点都会被唤醒并检查自己的前驱节点是否是首节点。节点间相互不进行通信



> 独占式同步状态获取流程：
>
> ```flow
> st=>start: 开始
> e=>end: 结束
> cond=>condition: 获取同步状态
> create=>operation: 生成节点
> joinTail=>operation: 加入同步队列尾部
> cond2=>condition: 前驱为头节点
> cond3=>condition: 获取同步状态
> wait=>operation: 线程进入等待状态
> setHead=>operation: 当前节点设置为头节点
> exit=>operation: 退出返回
> 
> 
> st->cond
> cond(yes)->exit
> cond(no)->create
> create->joinTail->cond2
> cond2(yes)->cond3
> cond2(no)->wait(right)->cond2
> cond3(no)->wait
> cond3(yes)->setHead(left)->exit
> exit->e
> 
> 
> ```

在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中**自旋**；移出队列的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。

##### 3. 共享式同步状态获取与释放

共享式与独占式的区别在于，同一时刻能否有多个线程同时获取到同步状态。

通过调用同步器的acquireShared(int arg)方法可以共享地获取同步状态。

同步器调用tryAcquireShared(int arg)方法来尝试获取同步状态，该方法的返回值为int类型，当返回值大于等于０时，表示能够获取到同步状态。因此，在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件是tryAcquireShared()方法返回值>=0。

共享式同步状态也需要释放同步状态，tryReleaseShared()方法释放同步状态后，将会唤醒后续处于等待状态的节点。该方法必须确保同步状态线程安全释放。一般是通过循环和ＣＡＳ来保证，因为释放同步状态的操作可以同时来自多个线程。

##### ４. 独占式超时获取同步状态

![avatar](https://img-blog.csdn.net/20180830162607150?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjY3ODE3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

解释：独占式超时获取同步状态与独占式获取同步状态流程上很类似。区别在于未获取到同步状态时的处理逻辑。acquire(int arg)未获取到同步状态时，会使当前线程一直处于等待状态，而doAcquireNanos(int arg, long nanosTimeout)会使当前线程等待nanoTimeout时间，线程在该时期内未获取到同步状态，将会从等待逻辑中自动返回。

### 5.3　重入锁

支持重新进入的锁。表示该锁能够支持一个线程对资源的重复加锁。此外，重入锁可以支持获取锁时的公平性与非公平性选择。

#### 5.3.1　实现重进入

​	任意线程在获取到锁后能够再次获取该锁而不被锁所阻塞。需要解决问题：

- 线程再次获得锁，锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取锁
- 锁的最终释放：线程重复n次获取锁，随后在第n次释放锁后，其他线程能够获取到该锁。

公平锁通过同步队列实现，代价是进行大量的线程切换。非公平锁作为默认实现，可能会导致线程饥饿，但是保证了性能。

#### 5.４　读写锁

读写锁维护了一对锁，一个读锁和一个写锁。通过分离读锁和写锁，使得并发性相比一般的排他锁有很大提升。

java并发包提供读写锁的实现是ReentrantReadWriteLock。

ReentrantReadWriteLock特性：

| 特性       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| 公平性选择 | 支持非公平(default)和公平的锁获取方式，吞吐量：非公平优于公平方式 |
| 重进入     | 支持重进入，以读写线程为例：读线程在获取读锁后，能够再次获取读锁。写线程在获取写锁后能够再次获取写锁或者读锁。 |
| **锁降级** | 遵循获取写锁，获取读锁再释放写锁的次序，写锁能够降级成读锁   |

#### 5.4.2　读写锁实现分析

**状态设计**

读写锁使用整型变量来维护读写状态，整型变量高１６位代表读状态，低１６位代表写状态。

假设同步状态为Ｓ，则写状态等于Ｓ＆0x0000FFFF,读状态等于S>>>16(无符号右移１６位)。写状态增加１时，等于Ｓ＋１，读状态增加１时，等于Ｓ＋(1<<16) = S+0x00010000。

**写锁的获取与释放**

由于写锁是一个支持可重入的排它锁，规则为：如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取(读状态不为０)或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。等待其他线程的读锁释放或写锁释放。

>  其他线程存在读锁时，写锁不能被获取的原因在于：读写锁要保证写锁的操作对所有读锁可见，如果允许读锁在已经被获取的情况下对写锁的获取，那么正在运行的线程无法感知到当前写线程的操作。
>
> 写锁的释放与ReentrantLock类似，每次释放均减少写状态，当写状态为０时表示写锁已经被释放

**读锁的获取与释放**

读锁时一个支持可重入的共享锁，能够被多个线程同时获取，读锁被成功获取后，增加读状态。获取过程中如果写锁已经被其他线程获取，则进入等待状态。由于读状态是所有线程获取读锁次数的总和，因此每个线程获取读锁的次数会保存在ThreadLocal中，由线程自身进行维护。

**锁降级**

锁降级指写锁降级成为读锁，其过程为获取写锁　－>获取读锁　－>　释放写锁。而不是释放写锁->获取读锁。

锁降级可以保证数据可见性，先释放写锁再获取读锁可能被阻塞。

ReentrantLock不支持锁升级(获取读锁，获取写锁，释放读锁)，这样可以保证数据可见性。

### 5.5 LockSupport工具

用于阻塞当前线程与唤醒处于阻塞状态线程的工具

### 5.6 Condition接口

任意java对象都有一组监视器方法，包括wait(),notify(),notifyAll()等方法，可以用于实现等待/通知模式。Condition接口实现了类似于监视器方法的功能，与Lock配合使用。

对比：

| 对比项                                           | Object Monitor Methods  | Condition                                                    |
| ------------------------------------------------ | ----------------------- | ------------------------------------------------------------ |
| 前置条件                                         | 获取对象的锁            | 调用Lock.lock()获取锁，再用Lock.newCondition()获取Condition对象 |
| 调用方式                                         | 直接调用：object.wait() | 直接调用:　condition.wait()                                  |
| 等待队列个数                                     | 一个                    | 多个                                                         |
| 当前线程释放锁进入等待状态                       | 支持                    | 支持                                                         |
| 当前线程释放锁进入等待状态，等待状态中不响应中断 | 不支持                  | 支持                                                         |
| 当前线程释放锁进入超时等待状态                   | 支持                    | 支持                                                         |
| 当前线程释放锁进入等待状态到将来某个时间         | 不支持                  | 支持                                                         |
| 唤醒队列中一个线程                               | 支持                    | 支持                                                         |
| －－－全部线程                                   | 支持                    | 支持                                                         |

Condition对象由Lock对象创建出来的，调用condiftion.await()方法，当前线程会释放锁并等待。其他线程调用condition中的signal()方法后，当前线程才从await()方法中返回，并在返回前已经获取了相关的锁。

实例代码：

```java
public class BoundedQueue<T>{
 	private Object[] items;
    private int addIndex,removeIndex,count;
    private Lock lock = new ReentrantLock();
    private Condition notEmpty = lock.newCondition();
    private Condition notFull = lock.newCondition();
    
    public BoundedQueue(int size){
        items=new Object[size];
    }
    public void add(T t) throws InterruptedException {
        lock.Lock();
        try {
            while(count == items.length)
                notFull.await();
            items[addIndex] = t;
            if(++addIndex == items.length)
                addIndex=0;
            ++count;
            notEmpty.signal();
        }finally{
            lock.unLock();
        }
    }
    public T remove()throws InterruptedException {
        lock.Lock();
        try {
            while (count == 0){
                notEmpty.await();
            }
            Object x = items[removeIndex];
            if(++removeIndex==items.length)
                removeIndex=0;
            --count;
            notFull.signal();
            return (T) x;
        }finally{
            lock.unLock();
        }
        
    }
}
```

#### 5.6.2 condition的实现分析

每个condition对象都包含着一个队列(等待队列)。

**１.等待队列**

等待队列是一个FIFO队列，在队列中每一个节点都包含一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，该线程就是释放锁，构造成节点加入等待队列并进入等待状态。事实上，节点定义复用了同步器中节点定义，同步队列和等待队列中节点类型都是同步器的静态内部类AbstractQueuedSynchronizer.Node.

![avatar](https://img-blog.csdn.net/20170929154424802?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFrZUNvbnRyYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列。

上述节点引用更新的过程没有使用CAS操作保证，因为调用了await()方法的线程必定是获取了锁的线程，也就是说通过锁来保证线程安全。

在Object监视器模型上，一个对象拥有一个同步队列和等待队列，并发包中的Lock(同步器)拥有一个同步队列和多个等待队列。

**２.等待**

调用Condition的await()方法，会使当前线程进入等待队列并释放锁，同步线程状态变为等待态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。

**３.通知**

调用Condition.singal()方法的前置条件是当前线程必须获得锁。

通过调用同步器的enq(Node node)方法，等待队列中的头节点线程安全地移动到同步队列。当节点移动到同步队列后，当前线程再使用LockSupport唤醒该节点的线程。

被唤醒的线程，将从await()方法的循环中退出，调用同步器的acquireQueued方法加入到获取同步状态的竞争中。成功获取到同步状态后，被唤醒的线程将从先前调用的await()方法返回，此时线程已经成功获取到锁。



---

---



## 第六章　java并发容器和框架



### 6.1　ConcurrentHashMap实现原理

#### 6.1.1 使用ConcurrentHashMap原因

１.不安全的HashMap

多线程环境下，执行HashMap的Put操作会引起死循环导致ＣＰＵ利用率达到１００％

原因是由于多线程会导致HashMap的entry链表形成环形数据结构，此时Entry的next节点永远不为空，发生死循环。

２.效率低下的HashTable

HashTabl使用synchronized来保证线程安全，但是在线程竞争激烈的情况下，HashTable效率很低。

３.ConcurrentHashMap的分段锁技术可以有效提升并发访问率

#### 6.1.2　ConcurrentHashMap的结构

ConcurrentHashMap是有Segment和HashEntry的数组结构组成。Segment是一种可重入锁，HashEntry则用于存储键值对。

一个ConcurrentHashMap里包含一个Segment数组，HashEntry结构和HashMap相似，是一种数组＋链表结构。当对HashEntry进行修改时需要获取它对应的Segment锁。

ConcurrentHashMap在初始化时，初始容量是２^N。

定位数据的散列算法会对元素的hashCode再次散列，以减少hash冲突，提高存取效率。

#### 6.1.5 ConcurrentHashMap 操作

**get操作**

get操作实现，先经过一次散列，然后使用这个散列值定位到segment,再通过散列算法定位到元素。

get操作不需要加锁，原因是由于所有的共享元素都是volatile类型，保证了共享变量的可见性。

**put操作**

插入操作时，在定位到目标HashEntry后，先判断是否需要扩容，后定位添加元素的位置。

**size操作**

先不加锁尝试两次统计count数，如果相同则认为count值为size，如果不同在进行加锁累加。



### 6.2 ConcurrentLinkedQueue

针对安全队列，实现方式有两种：一种是使用阻塞算法，用一个锁或者两个锁控制队列的进出。一种是使用非阻塞算法，通过循环CAS操作来实现。

ConcurrentLinkedQueue使用链表结构实现。使用CAS操作实现线程安全

#### 6.2.2　入队过程

入队做两件事：１将入队节点设置成当前队尾节点的下一个节点；２更新tail节点，如果tail节点的next不为空，则将入队节点设置为tail节点，如果tail节点的next节点为空，则将入队节点设置为tail节点的next节点。所以，tail节点不总是队尾节点。

定位尾节点

尾节点并不总是tail节点，每次入队都需要通过tail节点来找尾节点。尾节点可能是tail节点，也可能是tail的next节点。

设置入队节点为尾节点

如果p等于null,表示p是当前队列的尾节点，如果不为null,表示有其他线程更新了尾节点，需要重新获取尾节点。

#### 6.2.2 出队列

出队列就是从队列里返回一个节点元素，并清空该节点对元素的引用。

并不是每一次出队时都更新head节点，当head节点里有元素时，直接弹出head节点的元素，而不会更新head节点。当head节点里没有元素时，出队操作才会更新head节点。该方法目的是减少CAS操作更新head节点的消耗哦啊，提高出队效率。

### 6.3 Java中的阻塞队列

阻塞队列在队列的基础上附加两个额外操作，当队列满时阻塞插入操作，当队列空时，阻塞获取操作。

#### 6.3.2 java中的阻塞队列

java　７中提供了７个阻塞队列

**ArrayBlockingQueue**

由数组实现的有界阻塞队列，按照先入先出的原则对元素进行排序。

默认情况下不保证公平访问队列。

**LinkedBlockingQueue**

链表实现的有界阻塞队列，默认和最大长度为Integer.MAX_VALUE，遵循先入先出原则

**PriorityBlockingQueue**

支持优先级的无界阻塞队列，默认元素采取自然顺序升序排列，也可以自定义。不能保证同优先级元素的顺序

**DelayQueue**

支持延时获取元素的无界阻塞队列。队列使用PriorityQueue实现。队列中元素必须实现Delayed接口。

运用场景：

- 缓存系统设计：使用DelayQueue保存缓存元素的有效期。
- 定时任务调度：

**SynchronousQueue**

不存储元素的阻塞队列。

**LinkedTransferQueue**

链表结构组成的无界阻塞TransferQueue队列。队列的transfer方法可以将生产者传入的元素理解传输给消费者。如果没有消费者等待接收元素，则会将元素放在队列的tail节点，并等待消费者消费该元素后返回。

**LinkedBlockingDeque**

链表结构组成的双向阻塞队列。可以从队列的两端插入和移出元素。

#### 6.3.3 阻塞队列的实现原理

使用通知模式实现。

可以使用Condition通知模式。

### 6.4　Fork/Join框架



Fork/Join是java7里提供的一个用于并行执行任务的框架，把一个大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。

#### 6.4.2 工作窃取算法

指某个线程从其他队列里窃取任务来执行。任务分割后，每一个线程会有一个执行队列，线程在执行完自己队列中的任务后，会去从其他线程队列里窃取一个任务来执行。此时两个线程会同时访问一个队列，为了减少线程间的竞争，使用双端队列。

**优点**：充分利用线程进行并行计算，减少线程间的竞争。

**缺点**：某些情况下仍然存在竞争。并且该算法会消耗更多的系统资源。

#### 6.4.3 Fork/Join框架设计

**分割任务**：将任务分割成足够小的多个子任务

**执行任务合并结果**：分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。

Fork/Join提供两个类来完成上面两件事

１.ForkJoinTask:Fork/Join提供以下两个子类。

- RecursiveAction:用于没有返回结果的任务
- RecursiveTask:用于有返回结果的任务

２.ForkJoinPool：ForkJoinTask需要通过ForkJoinPool来执行

#### 6.4.6 Fork/Join框架的实现原理

ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责存放程序提交给ForkJoinPool的任务，ForkJoinWorkerThread数组负责执行这些人无

**ForkJoinTask的Fork方法的实现原理**
当我们调用ForkJoinTask的fork方法时，程序会把任务放在ForkJoinWorkerThread的pushTask的**workQueue**中，异步地执行这个任务，然后立即返回结果。

pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。

　**ForkJoinTask的join方法实现原理**

Join方法的主要作用是阻塞当前线程并等待获取结果。

它首先调用doJoin方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有4种：已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常（EXCEPTIONAL）。

1. 如果任务状态是已完成，则直接返回任务结果。
2. 如果任务状态是被取消，则直接抛出CancellationException
3. 如果任务状态是抛出异常，则直接抛出对应的异常

> 在doJoin()方法里，首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；如果没有执行完，则从任务数组里取出任务并执行。如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记录异常，并将任务状态设置为EXCEPTIONAL。



---

---



## 第七章　Java中的13个原子操作类

java从JDK1.5开始提供java.util.concurrent.atomic包，这个包的原子操作提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。

因为变量的类型很多，atomic里提供了４种类型13个类。分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新字段。Atomic里类基本都是Unsafe实现的包装类。

### 7.1 原子更新基本类型

提供以下三个类：

- AtomicBoolean:原子更新布尔类型
- AtomicInteger:原子更新整型
- AtomicLong:原子更新长整型

三个类提供的方法类似，其在更新值的时候使用循环CAS方法来进行更新操作。

> 对于java中的其他基本类型，也可以使用类似的操作来实现。查看Unsafe源码可以知道，Unsafe提供了３中CAS方法：compareAndSwapObject,compareAndSwapInt,compareAndSwapLong。在AtomicBoolean源码中，它先把boolean转化成int再使用compareAndSwapInt进行CAS操作，所以更新其他基本类型也可以使用类似思路

### 7.2 原子更新数组

通过原子方式更新数组里的某个元素，Atomic包里提供了４个类：

AtomicIntegerArray: 原子更新整型数组里的元素

AtomicLongArray: 原子更新长整型数组里的元素

AtomicReferenceArray: 原子更新引用类型数组里的元素

AtomicIntegerArray: 类主要是提供原子方式更新数组里的整型，其常用方法如下：

- int addAndGet(int i, int delta):以原子方式将输入值与索引i对应的元素相加；
- boolean compareAndSet(int i, int expect, int update): 如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update

### 7.3 原子更新引用类型

原子更新基本类型的AtomicInteger，只能更新一个变量，如果要更新多个变量，就需要使用原子更新引用类型提供的类，包括以下３个：

AtomicReference: 原子更新引用类型

AtomicReferenceFieldUpdater: 原子更新引用类型里的字段

AtmoicMarkableReference: 原子更新带标记位的引用类型

### 7.4 原子更新字段类

在需要原子地更新某个类里的字段时，需要使用原子更新字段类，包括以下３个：

AtomicIntegerFieldUpdater: 原子更新整型的字段的更新器

AtomicLongFieldUpdater: 原子更新长整型字段的更新器

AtomicStampedReference: 原子更新带版本号的引用类型。可用于原子地更新数据和数据的版本号，解决使用CAS进行原子更新时可能出现的ABA问题。



---

---



## 第八章　Java中的并发工具类



### 8.1 等待多线程完成的CountDownLatch

CountDownLatch允许一个或多个线程等待其他线程完成操作。

```java
public class CountDownLatchTest{
    static CountDownLatch c = new CountDownLatch(2);
    public static void main(String[] args)throws InterruptedException{
        new Thread(new Runnable) {
            @override
            public void run(){
                System.out.println(1);
                c.countDown();
                System.out.println(2);
                c.countDown();
            }
        }).start;
    c.await();
        System.out.println("3");
    }
}
```

调用CountDownLatch的countDown方法时，Ｎ(new实例的时候传入的值)就会减１，其await方法会阻塞当前线程，直到N变为０。

如果出现某个线程执行的比较慢的情况，可以调用await(long time,TimeUnit uint)方法，超时等待后取消阻塞。

>  CountDownLatch计数器初始值必须>=０，在为０的时候，调用await方法不会阻塞当前线程。并且，CountDownLatch不能重新初始化或者修改CountDownLatch对象内部计数器的值。

### 8.2 同步屏障CyclicBarrier

功能为：让一组线程到达一个屏障处被阻塞，直到组内所有线程都执行到该处后，该组线程才会继续执行。

用法为：先new一个CyclicBarrier实例(指定个数)，需要同步的线程在同步点处调用实例的await()方法。等到所有的线程都调用该方法后，调用方法的线程开始继续执行。

> CyclicBarrier和CountDownLatch区别：
>
> CountDownLatch只能使用一次，而CyclicBarrier的计数器可以使用reset()方法进行重置，如果计算发生错误，可以重置计数器，让线程重新执行一次。
>
> CyclicBarrier还提供其他方法，比如getNumberWaiting, 可以获得CyclicBarrier阻塞线程的数量。isBroken()方法可以用来了解阻塞的线程是否被中断。







