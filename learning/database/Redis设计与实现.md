## 第一部分 数据结构与对象

### 第二章  简单动态字串	

​	Redis没有直接使用C语言的字符串来表示，而是构建了一种简单字符串SDS(simple dynamic string)的抽象类型，SDS为Redis里默认使用的字符串表示

​	Redis中，C字符串只会作为字符串字面量用在一些无需对字符串进行修改的地方。

​	SDS除了被用作保存数据库中的字符串值意外，还被用作**缓冲区**：例如AOF缓冲区以及客户端状态中的输入缓冲区。

#### 2.1 SDS定义

结构：

```c
struct sdsdr{
	int len;	//记录buf中已经使用的字节数量
	int free;	//记录buf中还未使用的字节的数量
	char buf[];	//字节数组，用于保存字符串
}
```

​	SDS遵守C字符串以空字符结尾的管理，保存空字符的1字节空间不计入SDS长度里面，并且为结尾符分配额外的1字节空间。遵循该原则的好处是，SDS可以直接重用一部分C字符串函数库里的函数

#### 	2.2 SDS与C字符串的区别

- SDS常数复杂度获取字符串长度
- SDS不存在缓冲区溢出的问题，SDS会对修改的子串做检查，并自动修改空间大小，不会出现缓冲区溢出的问题
- SDS可以减少修改字符串带来的内存分配次数
  - C字符串在拼接时需要重新分配内存来扩展底层数组的空间大小，在截断时也要释放不需要的内存，否则会造成内存泄漏
  - SDS中数据空间可以被部分使用，所以，可以减少内存分配次数
    - 空间预分配：进行内存分配时，程序可以为SDS分配部分额外的内存空间。
      - 如果SDS进行修改后，长度小于1MB，那么程序每次分配时，长度*2，此时，已使用的长度与未使用的长度相同
      - 如果SDS进行修改后，长度大于1MB,那么每次会分配当前长度+1MB空间
      - 在扩展SDS空间之前，会检查当前空余的空间是否足够以决定是否需要对SDS进行扩展
    - 惰性空间释放：进行字符串缩短操作时，并不会立即对buf数组进行缩短，而是将多余的空间作为free空间以方便下次操作
- 二进制安全
  - C字符串数组遇到空字符会被认为是字符结尾，这样会漏掉后面的数据，而SDS并不会出现这种问题。SDS使用buf数组不是用来保存字符，而是保存一系列二进制数据。
- 兼容部分C字符串：由于Redis也遵循以'\0'结尾，所以兼容部分C字符串

**总结**

| C字符串                            | SDS                              |
| ---------------------------------- | -------------------------------- |
| 获取字符串长度时间复杂度O(n)       | O(1)                             |
| API不安全，可能会造成缓冲区溢出    | 安全                             |
| 修改字符串长度N次必然会执行N次操作 | 修改N次最多执行N次操作           |
| 只能保存文本数据                   | 可以保存文本或者二进制数据       |
| 可以使用所有<string.h>库中的函数   | 可以使用部分<string.h>库中的函数 |



### 第三章  链表

​	链表提供了高效的节点重排能力以及顺序性的节点访问方式，并且可以通过增删节点来灵活的调整链表长度

​	链表在Redis里使用很广泛，比如列表键底层实现之一就是链表。当一个列表键包含较多元素时，或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。

​	除了列表键以外，发布/订阅、慢查询、监视器等功能也用到了链表，Redis本身还使用链表来保存多个客户端的状态信息以及使用链表来构建客户端输出缓冲区。

#### 3.1  链表和链表节点的实现

**结构**

```c
typedef struct listNode{
    struct listNode *prev;
    struct listNode *next;
    void *value;
}
```

使用基于listNode的list来构建链表的话更方便：

```c
typedef struct list{
    listNode *head; //表头节点
    listNode *tail;	//表尾结点
    unsigned long len;	//链表所包含的节点数
    void *(*dup)(void *ptr);	//节点值复制函数
    void *(free)(void *ptr);	//节点值释放函数
    int (*match)(*void *ptr, void *key);	//节点值对比函数
}
```

list结构为链表提供了表头指针head, 表尾指针tail, 以及链表长度计数器len，而dup，free，match成员则是用于实现多态链表所需的类型特定函数。

- dup函数用于复制节点所保存的值
- free函数用于释放链表节点所保存的值
- match函数用于对比链表节点所保存的值和另一个输入值是否相等

**特性**

- 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)
- 无环：表头结点的prev指针和表尾结点的next指针都执行null，对链表的访问以null为终点
- 带表头指针和表尾指针：通过list结构的head指针和tail指针，获取头节点和尾结点的时间复杂度都是O(1)
- 带链表长度计数器
- 多态：使用void*指针来保存节点值，并且可以通过list结构的dup,free，match三个属性为节点值设置类型特定函数。



### 第四章  字典

​	字典，又称为符号表，关联数组或映射，是一种用于保存键值对的抽象数据结构。

​	在字典中，一个键可以和一个值进行关联，这些关联的键和值称为键值对。键值对的每一个键都是独一无二的

#### 4.1 字典的实现

​	Redis的字典使用哈希表作为底层实现。一个哈希表里面可以有多个哈希表节点。每个哈希节点就保存了一个字典中的键值对

##### 	4.1.1 哈希表

​	结构

```c
typedef struct dictht{
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
}dictht;
```

- table属性是一个数组，数组每一个元素都是指向一个dictEntry结构的指针，每个dictEntry结构保存一个键值对。
- size属性记录了哈希表大小，即table数组大小
- used属性记录哈希表已有节点数量
- sizemask属性的值等于size-1，用于计算索引

##### 4.1.2 哈希表节点

哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存一个键值对。

```c
typedef struct dictEntry{
    void *key;
    union{
        void *val;
        uint64_t u64;
        int64_t s64;
    }v;
    struct dictEntry *next;
}dictEntry;
```

##### 4.1.3  字典

```c
typedef struct dict{
	dictType *type;
    void *privdata;
    dictht ht[2];
    int rehashIndex;
}dict;
```

- type属性和privdata属性是针对不同类型的键值对。为创建多态字典而设置的
- privdata属性则保存了需要传给哪些特定函数的可选参数

​    ht属性是包含了两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，h[1]在进行rehash时才会用到。除了ht[1]之外，rehashIndex只有在进行扩容时才使用，平时的值为-1; 

#### 4.2  哈希算法

​	Redis计算哈希值和索引值方法：先使用字典设置的哈希函数，计算key的哈希值，在对sizemask做与操作得到index.

​	当字典被用作数据库底层实现，或者哈希键底层实现是，Redis使用MurmurHash2算法来计算键的哈希值。

### 4.3 解决键冲突

​	当有两个或以上数量的键被分配到哈希表的同一个索引上面会发生哈希冲突。

​	Redis的哈希表使用链地址法来解决键冲突。每个哈希节点都有一个next指针，多个哈希节点通过next指针构成一个单向链表。

### 4.4  rehash

​	为了让哈希表的负载因子维持在一个合理的范围之内，当哈希表的键值对数量太多或者太少是，程序需要对哈希表大小进行扩展或者收缩。

​	扩展和收缩哈希表可以通过执行rehash操作来完成，Redis对字典的哈希表执行rehash步骤如下：

- 为字典的ht[1]哈希表分配空间，这个哈希表大熊取决于要执行的操作，以及ht[0]当前包含的键值对数量
  - 如果执行扩展操作，那么ht[1]大大小为第一个大于等于ht[0].used*2的2\*n(大于原来已有键值对数量*2的最小2的幂次方)
  - 如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的最小2的幂次方
- 将保存在ht[0]中的所有键值对rehash到ht[1]上，重新计算key的hash值，然后映射到新的ht[1]哈希表上
- 当ht[0]上所有的键值对都迁移到ht[1]之后，释放ht[0]，并将ht[1]设置为ht[0]，并未ht[1]建立一个新的空白哈希表。

**扩展与收缩的条件**

扩展：

- 服务器目前没有正在执行的BGSAVE命令或者BGREWRITEAOF命令，并且哈希表负载因子大于等于1
- 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5(尽量减少在紫子进程开启时对内存写入操作，节约内存)

收缩：哈希表负载因子小于等于0.1时，程序会对哈希表进行收缩

### 4.5  渐进式rehash

​	为了避免rehash对服务器性能造成影响，服务器不是一次性将ht[0]里的数据全部rehash到ht[1]中，而是分多次，渐进的将ht[0]里的数据迁移到ht[1]中。

​	**详细步骤**

- 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表
- 在字典中维持一个索引计数器变量rehashIndex,并将它的值设置为0,表示rehash工作正式开始
- 在进行rehash期间，每次对字典进行添加，删除，查找或者更新操作时，程序除了执行指定的操作外，还会顺带将ht[0]哈希表在rehashIndex索引上的所有键值对rehash到ht[1]上，当rehash工作完成后，程序将rehashIndex属性的值+1
- 随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会迁移到ht[1]上，此时程序将rehashIndex设置为-1，表示rehash操作已完成

​	渐进式rehash时，字典会同时持有ht[0]和ht[1]两个哈希表，所以在渐进式rehash期间，字典的增删查找会在两个哈希表上进行。

​	另外渐进式rehash时，ht[0]中的键值对只减不增。



### 第五章  跳跃表

​	跳跃表是一种有序的数据结构，通过每个节点中维持多个指向其他节点的指针达到快速访问节点的目的。

​	跳跃表支持平均O(logN)，最坏O(N)的查询复杂度。

​	Redis中跳跃表有俩个地方用到：一个用作有序集合键，另一个是在集群节点中用作内部数据结构。

#### 5.1  跳跃表实现

​	跳跃表由两个结构定义，分别是zskiplistNod用于跳跃表节点，zskipList用于保存跳跃表信息

zskiplist:

- header:指向跳跃表的表头结点
- tail:指向跳跃表的表尾结点
- level: 记录目前跳跃表内，层数最大的个节点的层数(不算表头结点)
- length: 记录跳跃表长度，跳表内包含节点的个数

zskiplistNode:

- 层（level）:Node中数组记录层数，每层里面包含两个属性：前进指针和跨度，前进指针用于访问下一个节点，跨度用于标记前进指针指向的节点与当前节点的距离。
- 后退指针：记录当前节点的前一个节点，用于反向遍历
- 分值(score):跳表中节点排序用，分值相同的节点按照成员对象在字典序中大小进行排序
- 成员对象(obj)：保存节点内成员

注意表头节点和其他节点是一样的，但是表头结点不用于存储具体obj成员



### 第六章  整数集合

​	整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且元素量不多时，Redis会使用整数集合作为集合键的底层实现

#### 	6.1  整数集合的实现

​	整数集合可以保存int16_t，int32_t，int64_t的整数值，并且保证集合中不会出现重复元素。

```c
typedef struct intset{
	uint32_t encoding;
    uint32_t length;
    int8_t contents[];
}intset;
```

​	contents数组是整数集合的底层实现：整数集合每个元素都是contents数组的一个数组项，每个项

在数组中按照值大小从小到大有序排列，并在数组中不包含任何重复项。

​	虽然intset结构将contents属性声明为int8_t类型数组，但是数组实际不保存任何int8_t类型的值，而是取决于encoding属性的值：

- 如果encoding属性的值为INTSET_ENC_INT16,那么contents就是一个int16_t类型的数组。同理还有INTSET_ENC_INT32/INTSET_ENC_INT64

#### 6.2  升级

​	如果要将新元素放入到整数集合，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后才能将新元素添加到整数集合里面。

​	升级分为三步：

- 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间
- 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位置上，并且放置元素的过程中，需要维持底层数组的有序性质不变。
- 将新元素放到底层数组里面

每次向整数集合添加新元素都可能引起升级，进行升级是所有元素都需要进行类型转换，所以向整数类型中添加新元素时间复杂度O(N).添加元素使用插入法，将后面的元素依次后移。

优势：节约内存，提升灵活性

**整数集合不支持降级操作**



### 第七章  压缩列表

​	压缩列表是列表键和哈希键的底层实现之一。打你个列表键包含少量列表项，并且每个每个列表项要么就是个小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来进行存储。

#### 7.1  压缩列表的构成

​	压缩列表目的是节约内存，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。

| zlbbytes | zltail | zllen | entry1 | entry2 | ...  | entryN | zlend |
| -------- | ------ | ----- | ------ | ------ | ---- | ------ | ----- |
|          |        |       |        |        |      |        |       |

压缩列表由以下几部分构成：

| 属性    | 类型     | 长度  | 用途                                                         |
| ------- | -------- | ----- | ------------------------------------------------------------ |
| zlbytes | uint32_t | 4字节 | 记录整个压缩列表占用的内存字节数，在对压缩列表进行内存重分配，或者计算zlend的位置时使用 |
| zltail  | uint32_t | 4字节 | 记录压缩列表表尾结点距离压缩列表的起始地址有多少字节，通过该偏移量，程序无须遍历整个压缩列表就可以确定表尾结点的地址 |
| zllen   | uint16_t | 2字节 | 记录了压缩列表节点数量，最大65535                            |
| entryX  | 节点列表 | 不定  | 压缩列表内节点                                               |
| zlend   | uint8_t  | 1字节 | 特殊值0xFF,用于记录压缩列表末端                              |

#### 7.2  压缩列表节点构成

​	节点可以保存一个字节数组或者一个整数值。

​	每个压缩列表都由previous_entry_length、encoding、content三部分组成

##### 7.2.1  previous_entry_length

​	以字节为单位，记录前一个节点长度，长度可以是1字节或者5字节

- 如果前一节点长度小于254字节，那么previous_entry_length为一字节，保存前一节点长度
- 如果前节点长度大于等于254字节，那么previous_entry_length第一个字节被设置为0xFE,后面四个字节保存前节点长度

​    该属性可以实现对列表节点的反向遍历

##### 7.2.2  encoding

​	节点的encoding记录节点的content属性所保存数据的类型以及长度

##### 7.2.3  content

​	保存节点值，可以是字节数组或者整数，值得类型和长度由encoding决定。

#### 7.3  连锁更新

​	对压缩列表的节点长度进行改变时，可能出现连锁更新，具体来说，如果列表中有多个长度在250-254字节的节点，当出现preNode长度变长时，后续节点的previous_entry_length会由1字节改变成5字节，这样会发生连锁反应，导致每个节点都需要改变，那么Redis会对这种情况进行n次内存分配。其时间复杂度为O(N2).

实际操作中，该情况不太可能发生，所可以放心的使用压缩列表。



### 第八章  对象

​	Redis并没有直接使用前面的这些数据结构构建键值对数据库，而是基于这些数据结构创建一个对象系统，该系统中包含字符串对象，列表对象，哈希对象，集合对象和有序集合对象。

​	Redis的对象系统使用引用计数方式来进行内存回收。

Redis在创建键值对时，会创建一个key对象和一个value对象。每个对象的结构如下：

```c
typedef struct redisObject{
	unsigned type:4;	//类型
    unsigned encoding:4;	//编码
    void *ptr;			//指向底层的数据结构的指针
    ...
}redisObject;
```

​	Redis键只是字符串对象，值可以是5种类型其中一种类型的对象。

​	此外Redis对象系统使用**引用计数法**的内存回收机制。并且，Redis使用该技术实现了对象共享机制。该机制在适当的条件下，可以让多个数据库共享同一个对象来节约内存。

​	Redis键会带有对象的访问时间记录信息，这样可以实现某些删除策略

#### 8.1 对象类型与编码

​	Redis中对象可以是5种类型的一个。对于键对象来说都是字符串对象，但是对于值对象来说就不一定了。

| 类型常量     | 对象名称     |
| ------------ | ------------ |
| REDIS_STRING | 字符串对象   |
| REDIS_LIST   | 列表对象     |
| REDIS_HASH   | 哈希对象     |
| REDIS_SET    | 集合对象     |
| REDIS_ZSET   | 有序集合对象 |

##### 8.1.2 编码和底层实现

​	对象的ptr指针指向对象的底层数据结构，数据结构由对象的encoding属性决定。

| 编码常量                  | 对应的底层数据结构         |
| ------------------------- | -------------------------- |
| REDIS_ENCODING_INT        | long类型的整数             |
| REDIS_ENCODING_EMBSTR     | embstr编码的简单动态字符串 |
| REDIS_ENCODING_RAW        | 简单动态字串               |
| REDIS_ENCODING_HT         | 字典                       |
| REDIS_ENCODING_LINKEDLIST | 双端链表                   |
| REDIS_ENCODING_ZIPLIST    | 压缩列表                   |
| REDIS_ENCODING_INTSET     | 整数集合                   |
| REDIS_ENCODING_SKIPLIST   | 跳跃表和字典               |

​	每种类型的对象都使用了至少两种不同的编码

| 类型         | 编码                      | 对象                                       |
| ------------ | ------------------------- | ------------------------------------------ |
| REDIS_STRING | REDIS_ENCODING_INT        | 使用整数值实现的字符串对象                 |
| REDIS_STRING | REDIS_ENCODING_EMBSTR     | embstr编码的简单动态字符串实现的字符串对象 |
| REDIS_STRING | REDIS_ENCODING_RAW        | 简单动态字符串实现的字符串对象             |
| REDIS_LIST   | REDIS_ENCODING_ZIPLIST    | 压缩列表实现的列表对象                     |
| REDIS_LIST   | REDIS_ENCODING_LINKEDLIST | 双端列表实现的列表对象                     |
| REDIS_HASH   | REDIS_ENCODING_HT         | 字典实现的哈希对象                         |
| REDIS_HASH   | REDIS_ENCODING_ZIPLIST    | 压缩列表实现的哈希对象                     |
| REDIS_SET    | REDIS_ENCODING_INTSET     | 整数集合实现的集合对象                     |
| REDIS_SET    | REDIS_ENCODING_HT         | 字典实现的集合对象                         |
| REDIS_ZSET   | REDIS_ENCODING_ZIPLIST    | 压缩列表实现的有序集合对象                 |
| REDIS_ZSET   | REDIS_ENCODING_SKIPLIST   | 跳跃表和字典实现的有序集合对象             |

使用 OBJECT ENCODING命令可以查看键对应的值对象的编码。

通过encoding属性来设定对象所使用的编码，可以极大地提升Redis的灵活性和效率。

举例来说：列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：

- 因为压缩列表比双端列表更节约内存，并且元素较少时，在内存中可以连续的方式保存，可以更快的被载入缓存。
- 随着列表的元素越来越多，列表的底层实现会从压缩编码转化为双端列表。

#### 8.2 字符串对象

​	字符串对象编码可以是int,raw和embstr

​	如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么该字符串对象会将整数值保存在字符串对象结构的ptr属性里面(*void转化成long),并将字符串对象的编码设置为int.

​	如果字符串对象保存的是一个字符串值，并且这个字符串的长度**大于39字节**，那么底层实现是简单动态字串，编码设置为raw。

​	如果字符串对象保存的是字符串值，并且该串长度**小于等于39字节**，那么该对象会使用embstr编码的方式保存。

​	embstr编码是专门用于保存短字符串的一种优化编码方式，与raw编码一样，使用redisObject结构和sdsstr结构来表示字符串对象。但是raw会调用两次内存分配操作，分别创建redisObject结构和sdsstr结构，而embstr编码则会通过一次内存分配一块连续空间来创建这两个数据结构。

​	embstr编码的字符串在执行命令时，产生的效果和raw编码的字符串对象执行时相同。但有以下好处：

- embstr编码将创建字符串对象所需的内存分配由两次变为一次
- 释放embstr内存也只需一次，而raw需要两次
- embstr编码的对象所有数据保存在一块连续内存中，可以更好地利用缓存带来的优势

​	最后，可以用long double类型表示的浮点数在redis中也是字符串值来保存的。该类型数值如果需要计算，先将字符串表示转化为原来的类型进行运算然后将结果转化为字符串保存。

##### 8.2.1 编码的转换

​	int编码的字符串对象和embstr编码的在条件满足的情况下会被转化成raw编码的字符串对象。

​	比方说对int编码的字符串对象追加字符串，那么会形成一个新的字符串对象，并使用raw编码。

​	另外，**redis中没有为embstr编码的字符串对象编写任何修改程序**,embstr编码对象实际上是只读的。所以，对embstr编码对象修改后，会变成raw编码的对象。

#### 8.3 列表对象

​	列表对象的编码可以是ziplist或者linkedList。

​	zipliist编码的列表对象可以使用压缩列表作为底层实现。每个压缩列表节点保存了一个列表元素，压缩列表的元素在内存上连续？？

​	而使用linkedlist实现的列表在内存上可以不连续。

​	**字符串对象是唯一一个会被其他四种对象嵌套的对象**

​	当列表对象同时满足以下两个条件时，列表对象会使用ziplist编码

- 列表对象的所有字符串元素都小于64字节
- 列表对象保存的元素小于512个时；

其他列表对象使用linkedlist编码。

#### 8.4 哈希对象

​	哈希对象的编码可以是ziplist或者hashtable.

​	ziplist编码的哈希对象可以使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存里键的压缩列表节点推入到压缩列表尾部，然后将保存了值的压缩列表节点推入到压缩列表表尾。因此：

- 保存了同一键值对的两个节点总是紧挨在一起，键在前，值在后。

- 先添加到哈希对象的键值对会放在压缩列表的表头方向，后来的键值对会放在压缩列表的表尾方向。

  hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用字典键值对来保存，字典的每个键值对都是字符串对象。

##### 8.4.1 编码转换

​	当哈希对象同时满足以下两个条件时，使用ziplist编码：

	-	哈希对象保存的所有键值对的键和值的字符串都小于**64字节**
	-	哈希对象保存的键值对数量小于512个。

​	不满足两个条件的哈希对象使用HashTable编码。这两个条件的上限值可以被修改。

​	当使用ziplist编码所需的任意一个条件不能被满足时，对象的编码转换会被执行。保存在压缩列表里面的键值对会被转移到字典中。对象的编码会从ziplist编程hashtable。

#### 8.5 集合对象

​	集合对象的编码可以是inset或者hashtable。

> intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在证书集合里面
>
> ![avatar](http://redisbook.com/_images/graphviz-fbd8f0e1aaad0bdef314af55d01212f83cba8b59.png)
>
> HashTable编码的集合对象使用字典作为底层实现，字典的每一键都是一个字符串对象，每个字符串对象包含集合的一个元素，字典的值全部设为NULL。
>
> ![avatar](http://redisbook.com/_images/graphviz-3f77c5cca338422f418d6d11bc02109fc945e790.png)

**编码转换**

​	当集合对象同时满足以下两个条件时，对象使用intset编码，不满足时使用HashTable编码(条件的上限值可以修改)：

> - 集合对象保存的所有元素都是整数值；
> - 集合对象保存的元素数量不超过512个。

#### 8.6 有序集合对象

​	有序集合的编码可以是ziplist或者skiplist。

​	ziplist编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素成员(member)，第二个元素保存元素的分值(score)。

​	压缩列表内的集合元素按照分值大小从小打到排序，分值较小的被放置在靠近表头的位置，分值较大的放置在靠近表尾的方向。

![avatar](http://redisbook.com/_images/graphviz-61b04c9bb72915ec0374125ba9455bc6783db4ff.png)

![avatar](http://redisbook.com/_images/graphviz-8d7b7d0e78ad9d445ff14834e9e9618234395d46.png)

​	有序集合使用跳表编码时，由于跳表底层使用zset结构，其中包含一个字典(dict)和一个跳跃表(zskiplist)。

​	跳跃表zskiplist将元素按照分支从小打到进行排序，通过跳跃表可以对有序集合进行范围内操作。此外，zset中的字典结构中键保存元素成员，值保存元素分值。通过字典，程序查找时能够实现O(1)时间复杂度来查找给定成员的分值。

​	有序集合中每个语速的成员都是一个字符串对象，分值是double类型的浮点数。虽然zset结构同时使用跳跃表和字典来保存有序集合元素，但是其数据底层都是通过指针的形式来共享元素成员和分值，所以同时使用跳跃表和字典来保存有序集合元素不会产生数据冗余而浪费内存。

> 有序集合单一使用字典或者跳跃表来实现，会使得比起同时使用两种结构来说，性能会降低。

**编码转换**

当有序集合对象同时满足以下两个条件时，使用ziplist编码(条件的上限值可以修改)：

> - 有序集合保存的元素数量小于128个；
> - 有序集合保存的所有元素成员长度小于64字节。

#### 8.7 类型检查与命令多态

​	Redis中操作命令可以被分为两类：可以操作任何类型的命令和只能对特定类型进行操作的命令。

> 可以对任何类型的键执行：DEL，EXPIRE，RENAME，TYPE，OBJECT命令等。
>
> 只能对特定类型的键执行，如：
>
> - SET、GET、APPEND、STRLEN等只能对字符串键执行；
> - HDEL、HSET、HGET、HLEN等只能对哈希键执行；
> - RPUSH、LPOP、LINSERT、LLEN等只能对列表键执行；
> - SADD、SPOP、SINTER、SCARD等只能对集合键执行；
> - ZADD、ZCARD、ZRANK、ZSCORE等只能对有序集合键执行。

​	Redis在执行一个特定的类型命令前会检查键的类型是否正确，通过RedisObject结构的type实现。

**多态命令实现**

​	Redis除了会根据值对象的类型来判断是否能够执行指定命令外，还会根据对象的编码方式，选择正确的命令实现代码来执行，这是由于对象的底层数据结构的选择不确定性。 

#### 8.8 内存回收

​	由于C语言没有自动的垃圾回收，Redis在自己的对象系统中构建了一个**引用计数**方式来实现内存回收。每一个对象的Object结构中存在refcount属性。

> - 在创建一个新对象时，引用计数值初始化为1；
> - 当对象被一个新程序使用时，引用计数值+1；
> - 当对象不再被程序使用时，引用计数值-1;
> - 当引用计数值为0时，对应的对象内存被释放。

#### 8.9 对象共享

​	引用计数除了被用于内存回收外，还可以作用于对象共享。Redis中可以让多个键共享一个值对象，该对象每被一个键共享时，引用计数会+1。

目前来说，Redis会在初始化服务器时创建1W个字符串对象，包含0~9999所有整数值。当服务器需要用到这些字符串对象时，服务器会进行对象共享而不是新建对象。

其对象共享仅限于整数类型的字符串对象O(1)，对于普通的字符串对象不会进行共享，因为进行对象比较时间复杂度为O(N)。

#### 8.10 对象的空转时长

​	redisObject结构中包含type,encoding,ptr,refcount和lru属性。lru属性记录了对象最后一次被命令程序访问的时间。如果服务器打开了maxmemory选项，并且回收内存的算法为volatile-lru(在设置了超时属性的键集合中，使用lru策略删除键)或者allkeys-lru(在所有的键集合中使用lru策略删除键)，空转时间较高的键会优先被服务器释放，回收内存。

#### 8.11 重点回顾

- Redis数据库中每个键值对的键和值都是一个对象；
- Reids中有字符串，列表，集合，哈希，有序集合5种类型对象，每种对象至少有两种编码方式，不同编码方式可以在不同的使用场景上优化对象的使用效率；
- 服务器在执行命令前会判断该命令执行的键类型是否合法；
- Redis存在引用计数的对象回收机制，并且会对0~9999整数类型的字符串对象进行对象共享；
- 对象会记录自己最后一次被访问的时间，这个时间可以用于计算对象的空转时间。

### 第九章 数据库

#### 9.1 服务器中的数据库

​	Redis数据库定义在redis.h/redisServer结构的db数组中，每一个RedisDb代表一个数据库。在Redis进行初始化时，如果没有指定dbnum数值，则会默认创建16个数据库。

#### 9.2 切换数据库

​	Redis客户端在对数据执行命令时，会去目标数据库操作对应的对象。默认情况下，客户端操作0号数据库，且客户端可以通过SELECT命令来切换目标数据库。

​	在服务器内部，存在一个记录客户端状态的结构RedisClient，结构体中属性db记录了当前客户端指向的数据库指针。

​	对于多数据库的操作需要谨慎，最好在执行具体命令前进行显式切换数据库操作。

#### 9.3 数据库键空间

​	Redis是一个键值对数据库服务器，服务器中每个数据库都有一个redis.h/redisDb结构表示，redisDb结构的dict字典保存了数据库中所有键值对，该字典被称为键空间。

> 键空间的键也就是数据库的键，每一个键都是一个字符串对象；
>
> 键空间的值是数据库的值，每个值都可以是任意一种Redis对象。

**读写键空间时的维护操作**

使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的维护操作，包括：

> - 在读取一个键之后，服务器会根据键是否存在来更新键空间命中次数与不命中次数。
> - 读取键之后，服务器会更新该键的LRU时间。
> - 如果服务器在读取一个键时发现该键已经过期，则服务器会先删除该键然后再执行后续操作。
> - 如果客户端使用WATCH命令监视某个键，服务器会在对被监视的键进行修改后，将该键标记为脏，从而让事务程序注意到该键被修改过。
> - 服务器每修改一个键后，会对脏键计数器自增1，该计数器会出发服务器的持久化操作。
> - 如果服务器开启了数据库通知功能，那么在对键进行修改后，服务器会按配置发送相应的数据库通知。

#### 9.4 设置键的生存时间或过期时间

​	通过EXPIRE或者PEXPIRE命令，客户端可以设置键的过期时间。到期后服务器会自动删除生存时间为0的键。过期时间是一个UNIX时间戳。

​	Redis有4个不同的命令来设置键的生存时间或过期时间（EXPIRE、PRXPIRE、EXPIREAT、PEXPIREAT）。这四个命令最终都是使用PEXPIREAT命令来实现的。

​	redisDb中的expires字典保存了数据库中所有键的过期时间，该字典被称作过期字典。

> - 过期字典的键是一个指针，指向键空间的某个键对象；
> - 过期字典的值是一个long long类型的整数，这个整数保存了所指向的数据库键的过期时间。

​	使用PRESIST命令可以移除一个键的过期时间，该键在过期字典中被删除。

#### 9.5 过期键删除策略

​	删除策略有三种：

> **定时删除**：在设置键的过期时间的同时，创建一个定时器(timer)，让定时器在键的过期时间来临时，立即执行对键的删除操作；对内存友好，对CPU不友好；
>
> **惰性删除**：放任过期键不管，每次获取键时检查该键是否过期，如果过期则删除该键，否则返回该键。对CPU友好，对内存不友好；
>
> **定期删除**：每隔一段时间，程序对数据库进行一次检查，删除过期的键。折中方案。

#### 9.6 Redis过期键删除策略

​	Redis实际上使用惰性删除和定期删除两种策略。

**惰性删除策略**

​	过期键的惰性删除策略通过db.c/expireIfNeeded函数实现，所有读写数据库的Redis在执行前会调用该函数来检查键是否过期。

**定期删除策略**

​	定期删除策略有redis.c/activeExpireCycle函数实现，Redis服务器会周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，在每个数据库的过期字典中随机检查一部分键的过期时间，删除过期的键。

#### 9.7 AOF、RDB和复制功能对过期键的处理

**生成RDB文件**

​	在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库的键进行检查，过期的键会被过滤掉不会存储在RDB文件中。

**载入RDB文件**

​	在启动Redis服务器时，如果服务器开启了RDB功能，服务器在载入RDB文件时：

> - 如果服务器以主服务器模式运行，则会将RDB文件中过期的键过滤掉；
> - 如果服务器以从服务器模式运行，则会保村所有的RDB文件中的键，无论是否过期。从服务器会在后续过程中进行数据同步，原有的数据会被清空。

**AOF文件写入**

​	服务器使用AOF持久化时，如果数据库中某个键已经过期但未删除，则AOF文件不受影响。如果过期的键被删除，程序会向AOF文件中追加一条DEL命令来显式记录被删的键。

**AOF重写**

​	和生成RDB文件类似，过期的键会在重写过程中被过滤掉。

**复制**

​	当服务器运行在复制模式下时，从服务器对过期键的删除有主服务器控制，对于客户端的读命令，不作键的过期删除操作。

#### 9.8 数据库通知

​	该功能可以让客户端通过订阅给定的频道或者模式来获知数据库中键的变化以及数据库中命令的执行情况。

#### 9.9 重点回顾

- Redis服务器中所有数据都保存在redisServer.db数组中，数据库的数量有RedisServer.dbnum属性保存。
- 客户端通过修改目标数据库指针，来让它指向数据库数组中的不同元素以切换数据库。
- 数据库主要有dict和expires两个字典构成，其中dict保存键值对，expires则是过期字典。
- 对数据库所有操作构建于字典操作之上。
- expires字典的键指向某个键，值为过期时间，使用UNIX标识。
- Reids使用惰性删除策略与定期删除策略来删除过期的键。
- 执行SAVE或BGSAVE命令产生的RDB文件不会包含过期的键。
- 执行BGREWRITEAOF命令对AOF文件重写不包含已经过期的键。键被删除后，服务器会在AOF文件中追加一条DEL命令标识该键被删除。
- 复制模式下，从服务器对过期键的删除仅遵从主服务器的指令而不对客户端的指令作删除操作。
- 当Redis命令对数据库进行修改后，服务器会根据配置向客户端发送数据库通知。

### 第十章 RDB持久化

​	生成RDB文件有两种方式，一个是SAVE一个是BGSAVE。

​	SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕，这期间内服务器不处理任何请求。

​	BGSAVE会派生出一个子进程，由子进程负责创建RDB文件，服务器进程继续处理后续请求。

​	Redis没有专门用于载入RDB文件的命令，Redis服务器在启动时如果检测到RDB文件，则会自动载入。

​	由于AOF文件的更新频率高于RDB文件，所以如果服务器开启了AOF持久化功能，服务器会优先使用AOF文件来还原数据。

**SAVE执行时服务器状态**

​	执行SAVE命令时，整个服务器被阻塞，直到执行完毕。

**BGSAVE命令执行时服务器状态**

​	执行该命令期间，服务器仍然可以继续处理客户端命令请求。但此期间内对于SAVE，BGSAVE，BGREWRITEAOF命令会有所不同。

- 在BGSAVE命令执行期间，客户端发送的这三个命令都会被服务器拒绝执行。BGREWRITEAOF和BGSAVE命令不能同时执行，因为它俩同时执行会产生大量的磁盘写入操作。

RDB文件载入时服务器会处于阻塞状态，直到载入工作完成为止。

#### 10.2 自动间隔性保存

​	使用BGSAVE命令时可以通过配置服务器参数来实现定期执行BGSAVE命令。

#### 10.3 RDB文件结构

​	RDB文件包含以下部分：

| REDIS              | db_version               | databases                                 | EOF             | check_sum               |
| ------------------ | ------------------------ | ----------------------------------------- | --------------- | ----------------------- |
| 5字节，标识RDB文件 | 4字节，记录RDB文件版本号 | 包含0或任意多个数据库以及库中的键值对数据 | 1字节，结束标志 | 8字节无符号整数，校验和 |

具体databases里数据库中相关格式以及键值对存储方式略......

#### 10.4 分析RDB文件

#### 10.5 重点回顾

- RDB文件用于保存和还原Reids服务器所有数据库中的所有键值对数据。
- SAVE命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器。
- BGSAVE命令由子进程执行保存操作，该命令不会阻塞服务器。
- 服务器状态会保存所有用SAVE选项设计的保存条件，当任意一个条件被满足时，服务器自动执行BGSAVE命令。
- RDB文件是一个二进制文件，由多部分组成。
- 对于不同类型的键值对，RDB文件会使用不同的方式保存。

### 第十一章 AOF持久化

​	AOF持久化通过保存Redis服务器所执行的命令来记录数据库状态。

#### 11.1 AOF持久化的实现

​	AOF持久化功能实现分为命令追加，写入，文件同步三个步骤。

**命令追加**

​	服务器在执行完命令后会将该命令追加到aof缓冲区末尾。

**写入和同步**

​	服务器会调用flushAppendOnleFile函数考虑是否将aof缓冲区内容写入到AOF文件中，其写入方式有3种。

> - always:将aof 缓冲区所有内容写入并同步到AOF文件
> - everysec:将aof缓冲区内容写入到AOF文件，如果两次写入间隔超过1s,则对AOF文件进行同步，同步操作由专门线程负责(默认方式)
> - no:仅将aof缓冲区内容写入到AOF文件，不进行同步。同步由操作系统控制。

#### 11.2 AOF文件的载入与数据还原

​		服务器载入AOF文件并将命令全部执行一遍后，还原成关闭前的数据库状态。详细步骤如下：

- 创建一个不带网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端和和正常的客户端执行效果一样
- 从AOF文件中分析并取出一条写命令；
- 使用伪客户端执行被读出的写命令；
- 重复执行上述两个步骤直到所有写命令被执行完毕。

#### 11.3 AOF重写

​	AOF重写会新生成一个AOF文件并将原AOF文件替换掉。新生成的AOF文件通过读取当前数据库状态来实现。

​	AOF重写时，服务器会fork一个子进程来执行，期间内服务器仍然可以接受并处理请求命令。

​	AOF在后台重写时，服务器会开启一个重写缓冲区来记录期间内的新的写操作，Redis服务器会在执行完一个写命令后，将该写命令同时发送给AOF缓冲区和AOF重写缓冲区。

> AOF重写期间，服务器进程会执行以下3个动作：
>
> - 执行客户端发来的命令
> - 将执行后的写命令追加到AOF缓冲区
> - 将执行后的写命令追加到AOF重写缓冲区

​	当子进程完成AOF文件重写后，会发送给服务器进程一个完成信号，服务器进程会将AOF重写缓冲区内容写入到新的AOF文件中，并将新AOF文件原子的替换原AOF文件。

#### 11.4 重点回顾

- AOF文件通过保存所有修改数据库的写命令来记录服务器数据库状态。
- AOF文件中农所有写命令以Redis命令请求协议格式保存。
- 命令请求会先保存在AOF缓冲区，定期将缓冲区内容同步到AOF文件。
- 同步选项对AOF持久化功能以及Redis服务器性能存在影响。
- AOF重写会产生一个新的AOF文件，并能够还原数据库状态，体积更小。
- AOF重写时会开启一个AOF重写缓冲区，重写完毕后，服务器进程会将该缓冲区内容写入到新的AOF文件中，并原子的替换新旧AOF文件。

### 第十二章 事件

​	Redis服务器是一个事件驱动程序，其需要处理两类事件：

- 文件事件：Redis服务器通过套接字和客户端连接，文件事件就是服务器对套接字操作的抽象。服务器与客户端的通信会产生相应的文件事件，服务器会通过监听并处理这些事件来完成一系列网络通信操作。
- 时间事件：Redis服务器中的一些操作需要在给定的时间点执行，时间事件就是对这些定时操作的抽象。

#### 12.1 文件事件

**文件事件处理器构成**

**I/O多路复用程序的实现**

**事件的类型**

**API**

**文件事件的处理器**

#### 12.2 时间事件

**实现**

**API**

**时间事件应用实例：serverCron函数**

#### 12.3 事件的调度与执行

#### 12.4 重点回顾



### 第十三章 客户端

#### 13.1 客户端属性

**套接字描述符**

**名字**

**标志**

**输入缓冲区**

**命令与命令参数**

**命令的实现函数**

**输出缓冲区**

**身份验证**

**时间**

#### 13.2 客户端的创建与关闭

**创建普通客户端**

**关闭普通客户端**

**Lua脚本的伪客户端**

**AOF文件的伪客户端**

#### 13.3 重点回顾



### 第十四章 服务器

#### 14.1 命令请求的执行过程

- 客户端向服务器发送命令请求；
- 服务器接收并处理客户端请求，在数据库进行设置操作，产生命令回复OK；
- 服务器将命令回复OK发送给客户端；
- 客户端接收服务器返回的命令回复OK，打印给用户看。



## 第三部分 多机数据库的实现

### 第十五章 复制

#### 15.1 旧版复制功能的实现

​	Redis复制功能分为同步和命令传播两个操作：

- 同步操作用于将服务器的数据库状态更新至主服务器当前所处的数据库状态；
- 命令传播操作用于在主服务器状态被修改时，让主从服务器重新回到一致状态。

**同步**

​	当客户端发送SlAVEOF命令，从服务器需要执行同步操作复制主服务器状态。从服务器的同步操作需要通过向主服务器发送SYNC命令来完成。具体操作如下：

- 从服务器向主服务器发送SYNC命令；
- 主服务器收到命令后执行BGSAVE操作，后台生成一个RDB文件，并开启一个缓冲区记录期间内的所有写命令；
- 主服务器将生成的RDB文件发送给从服务器，从服务器接收到该文件后同步自身数据库状态；
- 主服务器将缓冲区内的所有写命令发送给从服务器，从服务器执行这些写命令，将自身状态更新到主服务器当前所处的状态。

**命令传播**

​	同步操作完成后，主从服务器达到一致状态后，主服务器状态会出现再次改变的情况，为了让主从服务器达到一致状态，主服务器会将新的写命令在自身执行操作的同时，也将该命令发送到从服务器。

#### 15.2 旧版复制功能的缺陷

​	从服务器对主服务器的复制可以分为以下两种情况：

- 初次复制

- 断线后重新复制

  对于初次复制来说，旧版复制功能可以很好地完成任务；对于断线后复制来说，其效率非常低。主服务器会执行BGSAVE命令生成RDB文件，该操作会耗费大量CPU,内存和I/O资源。主服务器将RDB文件发送给从服务器时会占用网络带宽资源。

#### 15.3 新版复制功能实现

​	Redis2.8版本开始，使用PSYNC代替SYNC命令来执行复制同步操作。

​	PSYNC具有完整同步和部分同步两种模式：

- 完整同步用于处理初次复制情况：完整同步的执行和SYNC命令的执行一致。
- 部分同步用于处理断线后复制的情况：当服务器在断线后重连主服务器时，如果条件允许，主服务器可以将主从服务器断开期间的写命令发送给从服务器，从服务器只接受并执行这些写命令。

#### 15.4 部分重同步的实现

​	部分重同步由以下三个部分组成：

- 主服务器的复制偏移量和从服务器的复制偏移量；
- 主服务器的复制积压缓冲区；
- 服务器的运行ID。

**复制偏移量**

​	执行复制的双方——主服务器和从服务器会分别维护一个复制偏移量。

- 主服务器每次向从服务器传播N字节数据时，就将自己的复制偏移量的值加上N；
- 从服务器每次收到主服务器的N字节数据时，就将自己的复制偏移量的值加上N。

​	通过对比主从服务器的复制偏移量可以知道二者状态是否一致。

**复制积压缓冲区**

​	复制积压缓冲区是由主服务器维护的一个固定长度先进先出的队列，默认大小为1MB(可以修改)。

​	主服务在写命令时，不仅会将该命令同步给从服务器，还会将该命令写入到复制积压缓冲区中。缓冲区会为队列中每个字节记录相应的偏移量。

​	当从服务器重连上主服务器时，从服务器会通过PSYNC命令将自身的复制偏移量offset告诉主服务器，主服务器根据该偏移量来决定对从服务器执行何种操作：

> - 如果offset偏移量之后的数据仍然存在复制积压缓冲区中，那么主服务器对从服务器执行部分重同步操作。
> - 如果offset偏移量之后的数据已经不再复制积压缓冲区中，那么主服务器会对从服务器执行完全同步操作。

**服务器运行ID**

​	部分重同步操作会用到服务器运行ID。

- 每个Redis都会存在自己的运行ID，在服务器启动时自动生成，ID有40个16进制数字组成。

#### 15.5 PSYNC命令实现

#### 15.6 复制的实现

- 设置主服务器端口
- 建立套接字连接
- 发送ping命令
- 身份验证
- 发送端口信息
- 同步
- 命令传播

#### 15.7 心跳检测

​	命令传播阶段，从服务器默认会以每秒一次的频率向主服务器发送命令：

- 检测主服务器状态
- 复制实现min-slaves选项(防止主服务器在不安全的情况下执行写命令，避免出现大规模主从不一致情况)
- 检测命令丢失(主服务器能够根据心跳来检测从服务器是否同步到先前的命令)

#### 15.8 重点回顾

- Redis 2.8 以前的复制功能不能高效的处理断线后的情况，2.8新添加的部分同步功能可以解决该问题。
- 部分重同步由复制偏移量、复制积压缓冲区、服务器运行ID三部分实现。
- 复制操作刚开始时，从服务器会成为主服务器的客户端，并通过向主服务器发送命令请求来进行复制，复制操作后期，主从服务器互为对方的客户端。
- 主从服务器通过命令传播机制来更新从服务器状态，保持主从一致。从服务器通过向主服务器发送心跳检测命令来保持数据一致。



### 第十六章 Sentinel哨兵

​	哨兵是Redis的高可用性解决方案：一个或者多个Sentinel实例组成的Sentinel系统来监视任意多个主服务器，以及这些主服务器下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器关联的某个从服务器升级为主服务器，然后又新的主服务器代替已经下线的主服务器继续处理命令请求。

​	运行过程如下：

> - 主服务器1下线；
> - 哨兵监视1下线后时间达到阈值，从其从服务器中随机选择一个服务器升级为主服务器，假设选择从服务器2；
> - 哨兵向其他的从服务器发送更新命令，告知新的主服务器为服务器2，并让从服务器执行复制操作。
> - 主服务器2开始正常工作，哨兵监视服务器1状态，并在服务器1上线时，将其设置为服务器2的从服务器。

#### 16.1 启动并初始化Sentinel

​	当一个sentinel启动时，会执行以下步骤：

- 初始化服务器；
- 将普通Redis服务器使用的代码替换成Sentinel专用代码；
- 初始化Sentinel状态；
- 根据给定的配置文件，初始化Sentinel的监视主服务器列表；
- 创建向主服务器的网络连接。

**初始化服务器**

​	Sentinel本质上只是一个特殊的Redis服务器，启动Redis第一步就是初始化一个普通的Redis服务器，但不载入数据文件。

**使用Sentinel专用代码**

**初始化Sentinel状态**

​	应用了Sentinel专用代码后，会初始化一个sentinelState结构，保存服务器中所有Sentinel功能有关状态。

...

#### 16.2 获取主服务器信息

​	Sentinel默认以10秒一次的频率，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来获取主服务器当前信息。

#### 16.3 获取从服务器信息

​	当Sentinel发现主服务器有新的从服务器出现时，Sentinel会为该从服务器创建相应的实例结构以及命令连接和订阅连接。

#### 16.4 向主服务器和从服务器发送消息

​	默认情况下，Sentinel会以每两秒一次的频率，通过命令连接向所有被监视的主服务器和从服务器发送命令。

#### 16.5 接收来自主服务器和从服务器的频道信息

​	Sentinel会通过订阅连接向服务器一直发送命令。

#### 16.6 检测主观下线状态

​	默认情况下，sentinel会每秒一次发送ping命令给所连接的实例(主服务器，从服务器，其他Sentinel)。

​	默认情况下，当一个实例超过50000毫秒返回给Sentinel无效回复时，Sentinel会将该实例标记为主观下线状态。

#### 16.7 检查客观下线状态

​	当Sentinel将一个主服务器标记为主观下线状态时，为了保证真实性，它会向其他监视该主服务器的Sentinel进行询问。当Sentinel从其他Sentinel接收到足够的下线判断后，Sentinel会将该主服务器标记为客观下线，并对主服务器执行故障转移操作。

#### 16.8 选举领头Sentinel

​	当一个主服务器被判断为客观下线时，监视该服务器的各个Sentinel会进行协商，选出一个领头Sentinel，并由领头Sentinel对下线主服务器进行故障迁移操作。选举规则如下：

> - 所有在线的Sentinel都有被选举成Sentinel的资格。
> - 每次进行领头Sentinel选举后，无论选举是否成功，都会对配置纪元的值自增一次；
> - 在一个配置纪元里，所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会，并且局部领头一旦设置，整个配置纪元就无法更改。
> - 每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel。
> - 设置局部领头的规则是先到先得
> - 如果某个Sentinel被半数以上的Sentinel设置成了局部领头，则该Sentinel为领头。
> - 由于一次纪元中每个Sentinel只能设置一个局部领头，所以在一次纪元内，最多会出现一个领头Sentinel。
> - 如果在一个纪元内没有出现领头Sentinel，那么一段时间后会再次进行选举。

#### 16.9 故障转移

​		领头Sentinel会对已经下线的主服务器执行故障迁移操作：

- 在以下线的主服务器的从服务器中选出一个从服务器，将其转化为主服务器；
- 让其他的所有从服务器复制新的主服务器数据。
- 将已下线的主服务器改成从服务器。



### 第十七章 集群

#### 17.1 节点

​	Redis刚启动的时候不会建立集群，建立集群时，各个节点需要使用CLUSTER MEET命令来来完成，具体命令格式如下：

```
CLUSTER MEET <ip> <port>
```

​	向一个节点发送该命令，会使得本节点与目标节点进行握手，握手成功时会将本节点加入到目标节点对应的集群中。

**启动节点**

​	Reids服务器在启动时会根据cluster-enabled配置选项是否为yes来决定是否开启服务器集群模式。

​	节点会继续使用redisServer结构来保存服务器状态，使用redisClient结构来保存客户端状态，主语在集群模式下的数据，节点会将它们保存到cluster.h/clusterNode结构、cluster.h/clusterLink结构以及cluster.h/clusterState结构里面。

#### 17.2 槽指派

​	Redis集群通过分片的方式来保存数据库的键值对，集群的整个数据库被分为**16384**个槽(slot)。每个数据库中的键都属于这些槽的其中一个。集群中每个节点会处理0个或者最多16384个槽。

​	当数据库中的16384个槽都有节点在处理时，集群处于上线状态；如果有任何一个槽未被处理，则集群处于下线状态。

**记录节点的槽指派信息**

​	clusterNode结构的slots属性和Numslot属性记录了节点负责处理那些槽。slots属性是一个二进制位数组，该数组长度为16384/8=2048字节。Redis根据数组中每一位是否为1来判断节点是否处理槽i。

​	服务器在检查节点是否处理某个槽时，其时间复杂度为O(1)。

​	集群中每个节点除了处理自己的槽记录以外，还会将自己的slots数组发送给其他节点并记录其他节点slots。因此，每个节点都会知道数据库中的每个槽由哪个节点负责。

**集群中命令执行**

​	当客户端向节点发送与数据库键有关的命令时，接收节点会检查该命令处理的数据属于哪个槽，并判断该槽是否由自己处理，如果是则直接处理该命令；如果不是，则向客户端返回一个MOVED错误并告知客户端正确的处理节点，客户端将该命令发送到正确的节点执行。MOVED命令格式如下：

```
MOVED <slot> <ip>:<port>
```

​	在集群中，节点只会使用0号数据库，而在单机模式下服务器没有这种限制。

#### 17.4 重新分片

​	Redis集群重新分片可以将任意数量的已经指派给某个节点的槽改派给另一个节点，相关槽的键值也会从源节点迁移到目标节点。

​	重新分片可以在线进行。重新分片过程中，集群不需要下线。

​	重新分片操作一般由Redis集群管理软件redis-tribb负责执行。其重新分片过程如下：

- 管理软件先通知目标节点，让其准备好导入槽i的键值对；
- 管理软件通知原节点，让其进行数据准备；
- 管理软件获取源节点需要导出的所有键；
- 管理软件将该键值对原子的发送给目标节点进行迁移。
- 迁移完成后，管理软件向集群中任意一个节点发送槽该表命令，将该槽指派给目标节点。改指派信息会最终发送给整个集群。

#### 17.5 ASK错误

​	重新分片的过程中会出现同一个槽中一部分键值保存在两个节点的情况，在这种情况下，客户端发送的命令会先达到原节点，由源节点进行处理。如果源节点处没有该键值，会向客户端返回一个ASK错误，并指引客户端往目标节点处发送需要执行的命令。

#### 17.6 复制与故障转移

​	对于集群来说，每个节点也会有若干个从节点来保证其服务正常。

​	集群中每个节点会定期向集群中其他节点发送PING消息来检测对方是否在线，如果在规定的时间没有收到节点返回的PONG消息，那么发送PING消息的节点会将接收消息的节点标记为**疑似下线**。

​	如果在集群里面，半数以上的主节点都将某个主节点标记为疑似下线，那么该节点会被标记为下线。

​	当主节点被标记为下线状态时，其关联的从节点开始对主节点进行故障转移。步骤如下：

- 复制下线主节点的所有从节点里面，会有一个节点被选中；
- 被选中的从节点执行SLAVEOF no one 命令，成为新的主节点；
- 新柱节点撤销所有对已下线的主节点槽指派，并将这些槽都指派给自己；
- 新主节点向集群广播一条PONG消息以通知集群中其他主节点。
- 新主节点开始接收和自己处理槽的有关命令请求。

**选举新的主节点**

- 集群的配置纪元，初始值设为0；

- 当集群里的某个节点进行一次故障转移操作时，纪元值+1；

- 每一个配置纪元，集群中负责处理的主节点都有一次投票机会，主节点会将票投给第一个向自己请求的从节点。

- 下线主节点的从节点发现自己的主节点下线时，会向集群广播一条消息，要求集群中其他主节点投票给自己。

- 从节点根据消息返回，来判断自己获得的投票支持数量。如果大于集群设置的规则，则自己会成为新的主节点。

- 如果在一次配置纪元内没有选出新的主节点，那么时间周期结束后会开启下一个周期，并重新开始选举。直到选出主节点为止。

  选举方式本质上为Raft算法。

#### 17.7 消息

​	集群中各个节点之间发送的消息主要有以下5种：

- MEET消息：当发送者接收到客户端发送的CLUSTER MEET消息时，发送者会向接收者发送MEET消息，请求接收者加入到当前所处的集群；
- PING消息：集群中每个节点默认每隔一秒就会从节点列表中随机选出5个节点然后给其中一个最长时间没发送过消息的节点发送PING消息以检测其是否在线；如果与某个节点的通信时间间隔超过设置时长的一半，那么也会向该节点发送PING消息；
- PONG消息：节点收到MEET消息或者PING消息时，需要返回PONG消息以确认。另外，节点可以广播PONG消息以让整个集群更新自己的信息；
- FALL消息：用来告知其他节点某节点A已经下线；
- PUBLISH消息：用于转发并执行消息内命令，集群中所有节点都会执行相同命令。

#### 17.8 重点回顾

- 节点通过握手来将其他节点添加到自己的集群中。
- 集群槽16384个，通过槽指派将所有的槽划分给不同的节点处理。
- 节点会处理自己所负责的槽的命令，对于不是自己负责的，会返回客户端MOVED错误并告知其正确的节点路由。
- Redis集群通过reids-trib来进行重新分片。重新分片可以将某个槽的所有键值对从一个节点转移到另一个节点。
- 在重新分片过程中，如果节点A没有找到对应的键，则会返回给客户端一个ASK错误，并指引其到节点B去处理需要执行的命令。数据正在通过重新分片从节点A转移到节点B中。
- ASK和MOVED错误很相似，ASK只是MOVED的一种特殊情况。
- 集群中主节点下线可以由关联的从节点代替。
- 集群节点使用消息进行通信，常见的消息有MEET、PING、PONG、PUBLISH、FAIL五种。



## 第四部分 独立功能的实现









