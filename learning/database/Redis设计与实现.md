## 第一部分 数据结构与对象

### 第二章  简单动态字串	

​	Redis没有直接使用C语言的字符串来表示，而是构建了一种简单字符串SDS(simple dynamic string)的抽象类型，SDS为Redis里默认使用的字符串表示

​	Redis中，C字符串只会作为字符串字面量用在一些无需对字符串进行修改的地方。

​	SDS除了被用作保存数据库中的字符串值意外，还被用作**缓冲区**：例如AOF缓冲区以及客户端状态中的输入缓冲区。

#### 2.1 SDS定义

结构：

```c
struct sdsdr{
	int len;	//记录buf中已经使用的字节数量
	int free;	//记录buf中还未使用的字节的数量
	char buf[];	//字节数组，用于保存字符串
}
```

​	SDS遵守C字符串以空字符结尾的管理，保存空字符的1字节空间不计入SDS长度里面，并且为结尾符分配额外的1字节空间。遵循该原则的好处是，SDS可以直接重用一部分C字符串函数库里的函数

#### 	2.2 SDS与C字符串的区别

- SDS常数复杂度获取字符串长度
- SDS不存在缓冲区溢出的问题，SDS会对修改的子串做检查，并自动修改空间大小，不会出现缓冲区溢出的问题
- SDS可以减少修改字符串带来的内存分配次数
  - C字符串在拼接时需要重新分配内存来扩展底层数组的空间大小，在截断时也要释放不需要的内存，否则会造成内存泄漏
  - SDS中数据空间可以被部分使用，所以，可以减少内存分配次数
    - 空间预分配：进行内存分配时，程序可以为SDS分配部分额外的内存空间。
      - 如果SDS进行修改后，长度小于1MB，那么程序每次分配时，长度*2，此时，已使用的长度与未使用的长度相同
      - 如果SDS进行修改后，长度大于1MB,那么每次会分配当前长度+1MB空间
      - 在扩展SDS空间之前，会检查当前空余的空间是否足够以决定是否需要对SDS进行扩展
    - 惰性空间释放：进行字符串缩短操作时，并不会立即对buf数组进行缩短，而是将多余的空间作为free空间以方便下次操作
- 二进制安全
  - C字符串数组遇到空字符会被认为是字符结尾，这样会漏掉后面的数据，而SDS并不会出现这种问题。SDS使用buf数组不是用来保存字符，而是保存一系列二进制数据。
- 兼容部分C字符串：由于Redis也遵循以'\0'结尾，所以兼容部分C字符串

**总结**

| C字符串                            | SDS                              |
| ---------------------------------- | -------------------------------- |
| 获取字符串长度时间复杂度O(n)       | O(1)                             |
| API不安全，可能会造成缓冲区溢出    | 安全                             |
| 修改字符串长度N次必然会执行N次操作 | 修改N次最多执行N次操作           |
| 只能保存文本数据                   | 可以保存文本或者二进制数据       |
| 可以使用所有<string.h>库中的函数   | 可以使用部分<string.h>库中的函数 |



### 第三章  链表

​	链表提供了高效的节点重排能力以及顺序性的节点访问方式，并且可以通过增删节点来灵活的调整链表长度

​	链表在Redis里使用很广泛，比如列表键底层实现之一就是链表。当一个列表键包含较多元素时，或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。

​	除了列表键以外，发布/订阅、慢查询、监视器等功能也用到了链表，Redis本身还使用链表来保存多个客户端的状态信息以及使用链表来构建客户端输出缓冲区。

#### 3.1  链表和链表节点的实现

**结构**

```c
typedef struct listNode{
    struct listNode *prev;
    struct listNode *next;
    void *value;
}
```

使用基于listNode的list来构建链表的话更方便：

```c
typedef struct list{
    listNode *head; //表头节点
    listNode *tail;	//表尾结点
    unsigned long len;	//链表所包含的节点数
    void *(*dup)(void *ptr);	//节点值复制函数
    void *(free)(void *ptr);	//节点值释放函数
    int (*match)(*void *ptr, void *key);	//节点值对比函数
}
```

list结构为链表提供了表头指针head, 表尾指针tail, 以及链表长度计数器len，而dup，free，match成员则是用于实现多态链表所需的类型特定函数。

- dup函数用于复制节点所保存的值
- free函数用于释放链表节点所保存的值
- match函数用于对比链表节点所保存的值和另一个输入值是否相等

**特性**

- 双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)
- 无环：表头结点的prev指针和表尾结点的next指针都执行null，对链表的访问以null为终点
- 带表头指针和表尾指针：通过list结构的head指针和tail指针，获取头节点和尾结点的时间复杂度都是O(1)
- 带链表长度计数器
- 多态：使用void*指针来保存节点值，并且可以通过list结构的dup,free，match三个属性为节点值设置类型特定函数。



### 第四章  字典

​	字典，又称为符号表，关联数组或映射，是一种用于保存键值对的抽象数据结构。

​	在字典中，一个键可以和一个值进行关联，这些关联的键和值称为键值对。键值对的每一个键都是独一无二的

#### 4.1 字典的实现

​	Redis的字典使用哈希表作为底层实现。一个哈希表里面可以有多个哈希表节点。每个哈希节点就保存了一个字典中的键值对

##### 	4.1.1 哈希表

​	结构

```c
typedef struct dictht{
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
}dictht;
```

- table属性是一个数组，数组每一个元素都是指向一个dictEntry结构的指针，每个dictEntry结构保存一个键值对。
- size属性记录了哈希表大小，即table数组大小
- used属性记录哈希表已有节点数量
- sizemask属性的值等于size-1，用于计算索引

##### 4.1.2 哈希表节点

哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存一个键值对。

```c
typedef struct dictEntry{
    void *key;
    union{
        void *val;
        uint64_t u64;
        int64_t s64;
    }v;
    struct dictEntry *next;
}dictEntry;
```

##### 4.1.3  字典

```c
typedef struct dict{
	dictType *type;
    void *privdata;
    dictht ht[2];
    int rehashIndex;
}dict;
```

- type属性和privdata属性是针对不同类型的键值对。为创建多态字典而设置的
- privdata属性则保存了需要传给哪些特定函数的可选参数

​    ht属性是包含了两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，h[1]在进行rehash时才会用到。除了ht[1]之外，rehashIndex只有在进行扩容时才使用，平时的值为-1; 

#### 4.2  哈希算法

​	Redis计算哈希值和索引值方法：先使用字典设置的哈希函数，计算key的哈希值，在对sizemask做与操作得到index.

​	当字典被用作数据库底层实现，或者哈希键底层实现是，Redis使用MurmurHash2算法来计算键的哈希值。

### 4.3 解决键冲突

​	当有两个或以上数量的键被分配到哈希表的同一个索引上面会发生哈希冲突。

​	Redis的哈希表使用链地址法来解决键冲突。每个哈希节点都有一个next指针，多个哈希节点通过next指针构成一个单向链表。

### 4.4  rehash

​	为了让哈希表的负载因子维持在一个合理的范围之内，当哈希表的键值对数量太多或者太少是，程序需要对哈希表大小进行扩展或者收缩。

​	扩展和收缩哈希表可以通过执行rehash操作来完成，Redis对字典的哈希表执行rehash步骤如下：

- 为字典的ht[1]哈希表分配空间，这个哈希表大熊取决于要执行的操作，以及ht[0]当前包含的键值对数量
  - 如果执行扩展操作，那么ht[1]大大小为第一个大于等于ht[0].used*2的2\*n(大于原来已有键值对数量*2的最小2的幂次方)
  - 如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的最小2的幂次方
- 将保存在ht[0]中的所有键值对rehash到ht[1]上，重新计算key的hash值，然后映射到新的ht[1]哈希表上
- 当ht[0]上所有的键值对都迁移到ht[1]之后，释放ht[0]，并将ht[1]设置为ht[0]，并未ht[1]建立一个新的空白哈希表。

**扩展与收缩的条件**

扩展：

- 服务器目前没有正在执行的BGSAVE命令或者BGREWRITEAOF命令，并且哈希表负载因子大于等于1
- 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5(尽量减少在紫子进程开启时对内存写入操作，节约内存)

收缩：哈希表负载因子小于等于0.1时，程序会对哈希表进行收缩

### 4.5  渐进式rehash

​	为了避免rehash对服务器性能造成影响，服务器不是一次性将ht[0]里的数据全部rehash到ht[1]中，而是分多次，渐进的将ht[0]里的数据迁移到ht[1]中。

​	**详细步骤**

- 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表
- 在字典中维持一个索引计数器变量rehashIndex,并将它的值设置为0,表示rehash工作正式开始
- 在进行rehash期间，每次对字典进行添加，删除，查找或者更新操作时，程序除了执行指定的操作外，还会顺带将ht[0]哈希表在rehashIndex索引上的所有键值对rehash到ht[1]上，当rehash工作完成后，程序将rehashIndex属性的值+1
- 随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会迁移到ht[1]上，此时程序将rehashIndex设置为-1，表示rehash操作已完成

​	渐进式rehash时，字典会同时持有ht[0]和ht[1]两个哈希表，所以在渐进式rehash期间，字典的增删查找会在两个哈希表上进行。

​	另外渐进式rehash时，ht[0]中的键值对只减不增。



### 第五章  跳跃表

​	跳跃表是一种有序的数据结构，通过每个节点中维持多个指向其他节点的指针达到快速访问节点的目的。

​	跳跃表支持平均O(logN)，最坏O(N)的查询复杂度。

​	Redis中跳跃表有俩个地方用到：一个用作有序集合键，另一个是在集群节点中用作内部数据结构。

#### 5.1  跳跃表实现

​	跳跃表由两个结构定义，分别是zskiplistNod用于跳跃表节点，zskipList用于保存跳跃表信息

zskiplist:

- header:指向跳跃表的表头结点
- tail:指向跳跃表的表尾结点
- level: 记录目前跳跃表内，层数最大的个节点的层数(不算表头结点)
- length: 记录跳跃表长度，跳表内包含节点的个数

zskiplistNode:

- 层（level）:Node中数组记录层数，每层里面包含两个属性：前进指针和跨度，前进指针用于访问下一个节点，跨度用于标记前进指针指向的节点与当前节点的距离。
- 后退指针：记录当前节点的前一个节点，用于反向遍历
- 分值(score):跳表中节点排序用，分值相同的节点按照成员对象在字典序中大小进行排序
- 成员对象(obj)：保存节点内成员

注意表头节点和其他节点是一样的，但是表头结点不用于存储具体obj成员



### 第六章  整数集合

​	整数集合是集合键的底层实现之一，当一个集合只包含整数值元素，并且元素量不多时，Redis会使用整数集合作为集合键的底层实现

#### 	6.1  整数集合的实现

​	整数集合可以保存int16_t，int32_t，int64_t的整数值，并且保证集合中不会出现重复元素。

```c
typedef struct intset{
	uint32_t encoding;
    uint32_t length;
    int8_t contents[];
}intset;
```

​	contents数组是整数集合的底层实现：整数集合每个元素都是contents数组的一个数组项，每个项

在数组中按照值大小从小到大有序排列，并在数组中不包含任何重复项。

​	虽然intset结构将contents属性声明为int8_t类型数组，但是数组实际不保存任何int8_t类型的值，而是取决于encoding属性的值：

- 如果encoding属性的值为INTSET_ENC_INT16,那么contents就是一个int16_t类型的数组。同理还有INTSET_ENC_INT32/INTSET_ENC_INT64

#### 6.2  升级

​	如果要将新元素放入到整数集合，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后才能将新元素添加到整数集合里面。

​	升级分为三步：

- 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间
- 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位置上，并且放置元素的过程中，需要维持底层数组的有序性质不变。
- 将新元素放到底层数组里面

每次向整数集合添加新元素都可能引起升级，进行升级是所有元素都需要进行类型转换，所以向整数类型中添加新元素时间复杂度O(N).添加元素使用插入法，将后面的元素依次后移。

优势：节约内存，提升灵活性

**整数集合不支持降级操作**



### 第七章  压缩列表

​	压缩列表是列表键和哈希键的底层实现之一。打你个列表键包含少量列表项，并且每个每个列表项要么就是个小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来进行存储。

#### 7.1  压缩列表的构成

​	压缩列表目的是节约内存，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。

| zlbbytes | zltail | zllen | entry1 | entry2 | ...  | entryN | zlend |
| -------- | ------ | ----- | ------ | ------ | ---- | ------ | ----- |
|          |        |       |        |        |      |        |       |

压缩列表由以下几部分构成：

| 属性    | 类型     | 长度  | 用途                                                         |
| ------- | -------- | ----- | ------------------------------------------------------------ |
| zlbytes | uint32_t | 4字节 | 记录整个压缩列表占用的内存字节数，在对压缩列表进行内存重分配，或者计算zlend的位置时使用 |
| zltail  | uint32_t | 4字节 | 记录压缩列表表尾结点距离压缩列表的起始地址有多少字节，通过该偏移量，程序无须遍历整个压缩列表就可以确定表尾结点的地址 |
| zllen   | uint16_t | 2字节 | 记录了压缩列表节点数量，最大65535                            |
| entryX  | 节点列表 | 不定  | 压缩列表内节点                                               |
| zlend   | uint8_t  | 1字节 | 特殊值0xFF,用于记录压缩列表末端                              |

#### 7.2  压缩列表节点构成

​	节点可以保存一个字节数组或者一个整数值。

​	每个压缩列表都由previous_entry_length、encoding、content三部分组成

##### 7.2.1  previous_entry_length

​	以字节为单位，记录前一个节点长度，长度可以是1字节或者5字节

- 如果前一节点长度小于254字节，那么previous_entry_length为一字节，保存前一节点长度
- 如果前节点长度大于等于254字节，那么previous_entry_length第一个字节被设置为0xFE,后面四个字节保存前节点长度

​    该属性可以实现对列表节点的反向遍历

##### 7.2.2  encoding

​	节点的encoding记录节点的content属性所保存数据的类型以及长度

##### 7.2.3  content

​	保存节点值，可以是字节数组或者整数，值得类型和长度由encoding决定。

#### 7.3  连锁更新

​	对压缩列表的节点长度进行改变时，可能出现连锁更新，具体来说，如果列表中有多个长度在250-254字节的节点，当出现preNode长度变长时，后续节点的previous_entry_length会由1字节改变成5字节，这样会发生连锁反应，导致每个节点都需要改变，那么Redis会对这种情况进行n次内存分配。其时间复杂度为O(N2).

实际操作中，该情况不太可能发生，所可以放心的使用压缩列表。



### 第八章  对象

​	Redis并没有直接使用前面的这些数据结构构建键值对数据库，而是基于这些数据结构创建一个对象系统，该系统中包含字符串对象，列表对象，哈希对象，集合对象和有序集合对象。

​	Redis的对象系统使用引用计数方式来进行内存回收。

Redis在创建键值对时，会创建一个key对象和一个value对象。每个对象的结构如下：

```c
typedef struct redisObject{
	unsigned type:4;	//类型
    unsigned encoding:4;	//编码
    void *ptr;			//指向底层的数据结构的指针
    ...
}redisObject;
```

​	Redis键只是字符串对象，值可以是5种类型其中一种类型的对象。

​	此外Redis对象系统使用**引用计数法**的内存回收机制。并且，Redis使用该技术实现了对象共享机制。该机制在适当的条件下，可以让多个数据库共享同一个对象来节约内存。

​	Redis键会带有对象的访问时间记录信息，这样可以实现某些删除策略

#### 8.1 对象类型与编码

​	Redis中对象可以是5种类型的一个。对于键对象来说都是字符串对象，但是对于值对象来说就不一定了。

| 类型常量     | 对象名称     |
| ------------ | ------------ |
| REDIS_STRING | 字符串对象   |
| REDIS_LIST   | 列表对象     |
| REDIS_HASH   | 哈希对象     |
| REDIS_SET    | 集合对象     |
| REDIS_ZSET   | 有序集合对象 |

##### 8.1.2 编码和底层实现

​	对象的ptr指针指向对象的底层数据结构，数据结构由对象的encoding属性决定。

| 编码常量                  | 对应的底层数据结构         |
| ------------------------- | -------------------------- |
| REDIS_ENCODING_INT        | long类型的整数             |
| REDIS_ENCODING_EMBSTR     | embstr编码的简单动态字符串 |
| REDIS_ENCODING_RAW        | 简单动态字串               |
| REDIS_ENCODING_HT         | 字典                       |
| REDIS_ENCODING_LINKEDLIST | 双端链表                   |
| REDIS_ENCODING_ZIPLIST    | 压缩列表                   |
| REDIS_ENCODING_INTSET     | 整数集合                   |
| REDIS_ENCODING_SKIPLIST   | 跳跃表和字典               |

​	每种类型的对象都使用了至少两种不同的编码

| 类型         | 编码                      | 对象                                       |
| ------------ | ------------------------- | ------------------------------------------ |
| REDIS_STRING | REDIS_ENCODING_INT        | 使用整数值实现的字符串对象                 |
| REDIS_STRING | REDIS_ENCODING_EMBSTR     | embstr编码的简单动态字符串实现的字符串对象 |
| REDIS_STRING | REDIS_ENCODING_RAW        | 简单动态字符串实现的字符串对象             |
| REDIS_LIST   | REDIS_ENCODING_ZIPLIST    | 压缩列表实现的列表对象                     |
| REDIS_LIST   | REDIS_ENCODING_LINKEDLIST | 双端列表实现的列表对象                     |
| REDIS_HASH   | REDIS_ENCODING_HT         | 字典实现的哈希对象                         |
| REDIS_HASH   | REDIS_ENCODING_ZIPLIST    | 压缩列表实现的哈希对象                     |
| REDIS_SET    | REDIS_ENCODING_INTSET     | 整数集合实现的集合对象                     |
| REDIS_SET    | REDIS_ENCODING_HT         | 字典实现的集合对象                         |
| REDIS_ZSET   | REDIS_ENCODING_ZIPLIST    | 压缩列表实现的有序集合对象                 |
| REDIS_ZSET   | REDIS_ENCODING_SKIPLIST   | 跳跃表和字典实现的有序集合对象             |

使用 OBJECT ENCODING命令可以查看键对应的值对象的编码。

通过encoding属性来设定对象所使用的编码，可以极大地提升Redis的灵活性和效率。

举例来说：列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：

- 因为压缩列表比双端列表更节约内存，并且元素较少时，在内存中可以连续的方式保存，可以更快的被载入缓存。
- 随着列表的元素越来越多，列表的底层实现会从压缩编码转化为双端列表。

#### 8.2 字符串对象

​	字符串对象编码可以是int,raw和embstr

​	如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么该字符串对象会将整数值保存在字符串对象结构的ptr属性里面(*void转化成long),并将字符串对象的编码设置为int.

​	如果字符串对象保存的是一个字符串值，并且这个字符串的长度**大于39字节**，那么底层实现是简单动态字串，编码设置为raw。

​	如果字符串对象保存的是字符串值，并且该串长度**小于等于39字节**，那么该对象会使用embstr编码的方式保存。

​	embstr编码是专门用于保存短字符串的一种优化编码方式，与raw编码一样，使用redisObject结构和sdsstr结构来表示字符串对象。但是raw会调用两次内存分配操作，分别创建redisObject结构和sdsstr结构，而embstr编码则会通过一次内存分配一块连续空间来创建这两个数据结构。

​	embstr编码的字符串在执行命令时，产生的效果和raw编码的字符串对象执行时相同。但有以下好处：

- embstr编码将创建字符串对象所需的内存分配由两次变为一次
- 释放embstr内存也只需一次，而raw需要两次
- embstr编码的对象所有数据保存在一块连续内存中，可以更好地利用缓存带来的优势

​	最后，可以用long double类型表示的浮点数在redis中也是字符串值来保存的。该类型数值如果需要计算，先将字符串表示转化为原来的类型进行运算然后将结果转化为字符串保存。

##### 8.2.1 编码的转换

​	int编码的字符串对象和embstr编码的在条件满足的情况下会被转化成raw编码的字符串对象。

​	比方说对int编码的字符串对象追加字符串，那么会形成一个新的字符串对象，并使用raw编码。

​	另外，**redis中没有为embstr编码的字符串对象编写任何修改程序**,embstr编码对象实际上是只读的。所以，对embstr编码对象修改后，会变成raw编码的对象。

#### 8.3 列表对象

​	列表对象的编码可以是ziplist或者linkedList。

​	zipliist编码的列表对象可以使用压缩列表作为底层实现。每个压缩列表节点保存了一个列表元素，压缩列表的元素在内存上连续？？

​	而使用linkedlist实现的列表在内存上可以不连续。

​	**字符串对象是唯一一个会被其他四种对象嵌套的对象**

​	当列表对象同时满足以下两个条件时，列表对象会使用ziplist编码

- 列表对象的所有字符串元素都小于64字节
- 列表对象保存的元素小于512个时；

其他列表对象使用linkedlist编码。

#### 8.4 哈希对象

​	哈希对象的编码可以是ziplist或者hashtable.

​	ziplist编码的哈希对象可以使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存里键的压缩列表节点推入到压缩列表尾部，然后将保存了值的压缩列表节点推入到压缩列表表尾。因此：

- 保存了同一键值对的两个节点总是紧挨在一起，键在前，值在后。
- 先添加到哈希对象的键值对会放在压缩列表的表头方向，后来的键值对会放在压缩列表的表尾方向。

  hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用字典键值对来保存，字典的每个键值对都是字符串对象。

​	当哈希对象同时满足以下两个条件时，使用ziplist编码：

	-	哈希对象保存的所有键值对的键和值的字符串**都小于64字节**
	-	哈希对象保存的键值对数量小于512个。

不满足两个条件的哈希对象使用HashTable编码。









































0--