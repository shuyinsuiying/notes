# Mysql面试题


#### 1.事务4大特性

- **原子性**：事务是一个不可分割的工作单位，事务中的操作要么都做，要么都不做
- **一致性**：如果事务执行之前数据库是一个完整性状态，事务结束后，无论事务是否执行成功，数据库仍然是一个完整性状态
- **隔离性**：多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间要数据隔离
- **持久性**：事务一旦被提交，它对数据库的改变是永久性的

#### 2.关系数据库与非关系数据库

关系数据库：采取关系模型来组织数据的数据库

#### 3.数据库隔离级别， 每个级别可能引发的问题

​	SQL标准定义了4类隔离级别

- **Read Uncommitted（读未提交）**：该级别，所有事务都可以看到其他未提交事务的执行结果。引发问题：脏读，不可重复度，幻读

- **Read Committed（读已提交）**:大多数数据库默认隔离级别。该级别，一个事务只能看见已经提交事务所作的改变。问题：不可重复读，幻读

- **Repeatable Read(可重复读)**:Mysql默认事务隔离级别。确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。问题：幻读

- **Serializable(串行化)**：强制事务排序，解决幻读问题

- > ![1552534240043](/home/zhou/.config/Typora/typora-user-images/1552534240043.png)

> - **脏读**：某事务已经更新一份数据，另一个事务此时读取了同一份数据，前一个事务RollBack操作，后一个事务读取的数据不正确
> - **不可重复读**：一个事务的两次查询数据不一致
> - **幻读**：一个事务的两次查询中数据数目不一致
> - **读不影响写**：事务以排他锁形式修改原始数据，读数据不加锁
> - **写不影响读**：事务以排他锁形式修改原始数据，当读取的行正在更新时，读取操作不会因此等待行上锁的释放。相反，InnoDB存储会去读取行的快照数据
> - **间隙锁**：防止幻读；当对数据进行范围检索时，对其范围内数据加锁

#### 4.Mysql锁算法,锁机制

数据库锁一般有两种，乐观锁与悲观锁。其中，乐观锁由用户去控制，其实现方式为使用版本号+时间戳的方式。

悲观锁即一般所说的数据库锁机制。其分类如下：

Mysql锁：

- 表级锁：开销小，加锁快，不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低
- 行级锁：开销大，加锁慢，会出现死锁，锁定粒度小，冲突率低，并发度最高；
- 页面锁：开销适中，会出现死锁，并发度一般，粒度界于二者中间

MyISAM:

​	MyISAM表锁：读写，写写之间操作是串行的，只读操作并行

​		读写同一张表请求竞争时，写请求优先执行，读请求等待．

InnoDB:

​	InnnoDB没有页锁，只有行锁，表锁

InnoDB行锁算法：

- **Record Lock**:单个行记录上的锁
- **Gap Lock**:间隙锁，锁定一个范围，但不包括记录本身；
- **Next-Key Lock**:Record+Gap，锁定一个范围，并且锁定记录本身。

行锁细分：

- 共享锁
  - 加锁与解锁：当一个事务执行select时，数据库系统为该事物分配一把共享锁用来锁定数据。一个事务读操作过程中，允许其他事务同时更新锁定表中的行。
  - 共享锁能够防止共享锁和更新锁
  - 具有良好的并发性能，数据被放置共享锁后，还可以放置共享锁和更新锁，提高并发性
- 排它锁
  - 加锁与解锁：当一个事务执行insert/update/delete语句时，数据库对操作数据加排它锁如果该数据资源被占用，则服务放置独占锁
  - 兼容性：排它锁无法与其它锁兼容，如果数据已经加了排它锁，则无法放置其它锁。
  - 并发性：最差
- 更新锁：
  - 加锁与解锁：数据库涉及到修改操作时，事务在读取完数据之后对修改的数据加一把更新锁，其它事务要修改该数据时，会判断是否有更新锁，如果有则等待。
  - 兼容性：更新锁与共享锁兼容。也就是说，一个资源可以同时放置更新锁和共享锁。最多放置一把更新锁。多个事务同时更新某条数据时，只有一个事务能够获得更新锁。
  - 并发性：运行多个事务同时读取锁定数据，而不允许其他事务修改。

#### 5.Mysql的MVCC

​	MVCC全称“**多版本并发控制**”。可以在查询一些正在被另一个事务更新的行，并且可以看到他们被更新之前的值。

> 多版本并发控制：其实就是在每一行记录的后面增加两个隐藏列，记录创建版本号和删除版本号。每一个事务在启动时，都有一个惟一的递增版本号

- 查询：InnoDB会检索行的创建版本是否小于当前事务版本，删除版本是否大于当前事务版本，符合要求的行才会作为查询结果
- Delete:InnoDB会为当前删除的行的删除版本号做标记
- Update:InnoDB执行Update实际上复制需要更新的行再新插入了一条记录(delete+insert)，同时保存当前要原来操作行的删除版本号
- Insert:将新插入的行的创建版本号设置为当前系统的版本号。

写操作同时会将该操作写入undo log.

由旧数据并不真正删除，所以InnoDB会开启一个后台线程进行清理工作，规则是将删除版本号小于当前系统版本的行删除，该过程叫做purge.purge是通过遍历undo log实现.

#### 6.快照读和当前读

> **快照读**：读取的是快照版本，也就是历史版本
>
> **当前读**：读取的是最新版本
>
> 普通的select是快照读，update，delete,insert,select... lock in share mode,select ... for update是当前读

#### 7.乐观锁与悲观锁

- **悲观锁**：数据库认为每次事务都会有其他事务操作它要操作的数据，因此在数据库处理过程中将数据加锁。实现依靠数据库底层；
- **乐观锁**：事务认为别人不会去修改自己需要的数据，只有在提交更新的时候采取检查数据的状态。通常是给数据增加一个字段来标识数据的版本。

#### 8. 什么是一致性非锁定读

​	InnoDB用多版本来提供查询数据库在某个时间点的快照。如果隔离级别是Repeatable Read ,那么同一事务中的所有一致性读都读的是事务中第一个这样的读读到的快照；如果是Read Committed 那么一个事务中每一个一致性读读到的是它最新的快照版本；

​	简而言之，可重复读级别，一致性非锁定读，读到的数据是一个快照版本，与数据是否被更新无关；读已提交级别，读到的数据是最新的快照版本，可能出现“**幻读**”

#### 9. Mysql两种存储引擎的区别，各自适用场景

> **MyISAM**
>
> - 不支持事务，但每次查询都是原子操作;
> - 支持表级锁，每次操作都是对表加锁；
> - 存储表的总行数
> - 一个MyISAM表有三个文件：索引文件(.MYI)，表结构文件(.frm)，数据文件(.MYD)；
> - 采用非聚簇索引，索引文件的数据域指向数据文件的指针。辅索引与主索引基本一致，但辅索引不保证一致性
> - 适用OLAP（On-Line Analytical Processing 联机分析处理），强调数据分析，SQL执行时长，磁盘I/O，分区等；
> - 大量高并发读写会引起表损坏情况

> **InnoDB**
>
> - 支持ACID事务，支持事务的四种隔离级别
> - 支持行级锁以及外键约束，支持并发写(innodb行级锁可能会导致死锁，因为行级锁不是直接锁记录，而是锁索引)
> - 不存储总行数
> - 一个InnoDB引擎存储在一个文件空间(**共享表空间**，表大小不受操作系统控制，一个表可能分布在多个文件里)，也有可能为多个(表大小受操作系统限制，一般为2G)，受操作系统文件大小限制．或者多表空间，一个表空间文件存储一个表
> - 主键索引采取聚集索引，辅索引数据域存储主键的值，从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引
> - delete操作时，不会重建表，而是在原表上逐行删除
> - 最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整
> - 适用OLTP(联机事务处理)，强调内存各种指标命令率，并发操作

#### 10.B+索引和hash索引，各自区别

- 如果是等值查询，hash索引有明显优势，前提是键值唯一。键值不唯一，需要先找到键所在位置，然后根据链表向后扫描，直到找到相应数据；
- 如果是范围索引，无法使用hash索引
- hash索引无法利用索引完成排序，以及like ‘xxx%’ 这样的模糊查询
- hash索引不支持多列联合索引的最左匹配值
- B+树索引的关键字检索效率比较平均，在有大量键值重复情况下，hash索引效率低下；

#### 11. 为什么B+树适合作为索引的结构

B树：有序数组+平衡多叉数

B+树：有序数组链表+平衡多叉树，叶子存储数据，占用空间小，双链表修改效率高

B树适合随机检索，B+树同时支持随机检索和顺序检索

**原因**：B树在提高了磁盘IO性能的同时没有解决元素遍历的效率低下问题。B+树只要遍历叶子节点就可以实现整颗树遍历；平衡二叉树没有充分利用磁盘预读功能。

 1、 B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。**

 2、B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

 3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。

#### 12. B+索引数据结构和B树的区别？

```java
//TODO:
```

B树：

- 根节点至少包含两个子节点
- 每个中间节点包括k-1个元素和k个子节点，其中m/2 <= k <= m
- 每一个叶子节点包含k-1个元素，其中m/2 <= k <=m
- 每个节点的元素从大到小排序，节点当中k-1个元素是k个子节点的值域的划分

B+树：

- 有k个子树的中间节点包含有k个元素，每个元素不保存数据，只用于索引，所有数据保存在叶子节点中
- 叶子节点包含了全部元素的信息，以及指向这些元素记录的指针，并且叶子节点从小达到顺序连接
- 所有中间节点元素都存在于叶子节点中

区别：

- B+树中间节点不存储数据，所以，磁盘页能够容纳更多的元素；
- b+树查找时定位到叶子节点,可以通过叶子节点实现整个树的遍历，而B树查找时，可能在中间节点就返回；
- 由于B+树叶子节点有链表结构连接，所以，Ｂ＋树在范围查找来说，优于B树．
- B+树查询效率更稳定

#### 13. 索引的分类(主键索引，唯一索引)，最左前缀原则，哪些情况索引会失效？

> **索引分类**：
>
> - 普通索引：最基本索引，没有任何限制
> - 唯一索引：索引列的值必须唯一，但允许有空值
> - 主键索引：特殊的唯一索引，不允许有空值
> - 全文索引：仅可用于MyISAM表，针对较大数据，生成全文索引很消耗时间
> - 组合索引：可以提高MySQL效率，遵循最左前缀原则
> - 覆盖索引：包含所有需要查询的字段值的索引

最左匹配原则就是数据库在进行索引查找时，遵循最左优先原则，在这种情况下，创建复合索引时，要使索引生效，需要按照最左匹配原则来进行查找。

#### 14. 聚集索引和非聚集索引

**聚集索引**：也叫聚簇索引，指数据行的物理顺序与列值(一般是主键列)的逻辑顺序相同，一个表只能有一个聚集索引；

> 如果没有定义主键，会选择一个唯一的非空索引代替，如果没有这样的索引，则会隐式定义一个主键作为聚簇索引

**非聚簇索引**：索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表可以拥有多个非聚簇索引；

> 使用聚集索引的查询效率要比非聚集索引高，但频繁去改变聚集索引的值，写入性能不高，因为需要移动对应数据的物理位置；
>
> 非聚集索引在查询时尽量避免二次查询，提升性能；
>
> 不是所有的表都适合建立索引，只有数据量大的表才适合建立索引，且建立在选择性高的列上性能更好。

#### 15. 数据库三大范式

**第一范式**：当关系模式R的所有属性都不能分解为更基本的单位时，称R是满足第一范式的，1NF；

**第二范式**：如果关系模式R满足第一范式，并且R的所有非主属性都完全依赖与R的每一个候选关键属性，称R满足第二范式；

**第三范式**：设R满足第一范式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式。 

> 说明：
>
> 第一范式是对关系模式的基本要求，不满足第一范式的数据库不是关系数据库，它指的是数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值；
>
> 第二范式要求数据库表中每个实例或行必须被惟一的区分，各字段和主键之间不存在部分依赖；
>
> 第三范式要求数据库表中不包含已在其他表中的非主关键字信息。不存在传递依赖。

#### 17. MySql并发情况下解决

- 代码中sql语句优化
- 数据库字段优化，索引优化
- 加缓存，redis/memcache等
- 主从，读写分离，集群，分流，横向扩展
- 分区
- 垂直拆分，解耦模块
- 水平切分，分片

#### 18. Mysql复制原理，三个线程之间的关系

- 在Slave服务器上执行start slave命令开启主从复制开关，开始进行主从复制
- Slave服务器的IO线程会通过master上已经授权的复制用户权限请求连接master服务器，并请求从执行binlog日志文件的**指定位置之后**开始发送binlog日志内容
- master服务器接收到来自Slave服务器的IO线程请求后，二进制转储IO线程会根据Slave服务器的IO线程请求信息分批读取指定binlog日志文件指定位置后的binlog日志信息，然后返回给Slave的IO线程。返回的信息除了日志内容外，还有Master服务器端记录的新的binlog文件名称，新binlog的下一个指定更新位置
- 当Slave服务器的IO线程获取到master服务器上IO线程发送的日志内容，日志文件以及位置点后，将binlog日志内容写到Relaylog文件(中继文件)末端，并将新的binlog名称和位置记录到master-info文件中，方便下一次读取
- Slave端的SQL线程会实时检测RelayLog中IO线程新增的日志内容，然后及时把RelayLog文件中的内容解析成Sql语句，并在自身Slave服务器上执行。然后在relay-log.info中记录当前应用中继日志的文件名和位置点。

#### 19. InnoDB4个特性

- **insert Buffer**:用于欺骗数据库；对于非唯一索引，辅助索引的修改操作并非实时更新索引的叶子页，而是将若干对同一页面的更新缓存起来合并成一次性更新操作，转化随机IO为顺序IO，避免随机IO带来的性能损耗，提高数据库写性能；
- **Double Write**:保证数据可靠性，防止由于宕机引起的数据写失效。innodb在进行写操作到磁盘时，并不直接写到数据文件中，而是将数据先拷贝到内存的写缓冲区(2M)，然后将写缓冲区数据分两次写入磁盘的共享表空间中，每次1M，然后再将写缓冲区写入数据文件。 (第一次写失败怎么办？)
- **自适应哈希**：innodb会监控对表上索引的查找，如果观察到建立哈希索引可以带来的速度提升，则建立哈希索引；
- **read-ahead**:innoDB提供了两种方式的预读**线性预读**与**随机预读**；innodb以64个page为一个extent,linear read-ahead在连续读取一个extent时候，会触发下一个extent的预读；random read-ahead在连续读取了设定数量的page后，会触发读取该extent的剩余page.

#### 20 mysql7种日志

- **重做日志(redo log)**
  - 作用：确保事务持久性。防止在发生故障时有脏页未写入磁盘，重启mysql服务时，根据redo log进行重做。达到事务持久性
  - 事务开始时就会产生redo log，事务的脏页写入磁盘后，重做日志占用的空间可以重用；
- **回滚日志(undo log)**
  - 保存了事务发生之前的数据版本，可以用于回滚以及MVCC下的读
  - 事务开始前，生成当前版本的回滚日志，执行回滚日志时，只是将数据从逻辑上恢复至事务之前的状态，而不是物理页面上操作实现；事务提交后，不能马上删除回滚日志，而是将其放入待清理链表
- **二进制日志(binlog)**
  - 用于复制，实现主从同步；
  - 可以基于binlog做到类似于oracle的闪回功能；

- **错误日志**

  - 记录mysqld启动和停止，以及服务器运行过程中发生的错误信息；
- **慢查询日志**

  - 记录执行时间过长和没有使用索引的查询语句，并且只会记录执行成功的语句
- **一般查询日志**

  - 记录服务器收到的查询命令
- **中继日志(relay log)**

  - 用来给salve库恢复用

  >  一般来说，mysql崩溃后，重启服务会通过回滚日志将所有已完成并写入磁盘的未完成事务进行rollback，然后redo一遍所有事务。redo日志会有一个checkpoint，当脏页数据刷新到磁盘后，checkpoint会记录到redo log的结尾位置，数据回复时，只需要恢复checkpoint后的数据。

#### 21. mysql如何设置，以支持emoji表情

- 建库的时候，数据库类型集使用utf8-general-ci类型
- 建表的时候，表格类型集(Collation)选择utf8mb4-general-ci

#### 22. mysql数据库CPU飙升时解决方案

思路：找到cpu占用率高的线程

- 先使用top查看机器进程CPU资源占用；
- 进入mysql，使用show processeslist查看进程状况，是否有被锁住的进程；
- 查看是否有慢sql在运行，show full processlist; 
- explain分析sql是否有索引，对sql进行优化
- 查看是否缓存失效引起，查看buffer命中率

#### 23. mysql explain用法，profile使用

使用时直接在语句前面加上explain即可；

显示信息解释：

- table:表格名
- type:显示连接使用何种类型
- possible_keys:可能应用在该表上的索引；
- key:实际使用的索引
- key_len:使用索引的长度
- ref:显示哪一列被使用
- row:返回数据的行数
- extra:额外信息
- partition:分配的分区
- filtered:过滤的数据百分比

Profile用于查询SQL语句的执行时间，并且列出cpu/memory的使用量。执行过程中Systemlock,Table lock花多少时间。 

#### 24. mysql备份 mysqldump和xtrabackup

​	二者都属于热备份(在不关闭数据库的情况下实现备份)。

Mysqldump:适用于业务量不大的数据库备份

- 调用FTWRL(flush tables with read lock) 全局禁止读写
- 开启快照读，获取此时快照(innodb)
- 备份非innodb表(*.frm, *.myi,*.myd)等
- 非innodb表备份完毕，释放FTWRL锁
- 逐一备份innodb表数据

![avatar](https://images2015.cnblogs.com/blog/176539/201605/176539-20160503090539826-471170339.png)

xtrabackup:基于innodb的crash恢复功能实现的。

- 启动备份时记录redo log的日志序列号(log sequence number)，并后台进程监测mysql的事务日志；

- 开始拷贝数据文件，并执行redo log的变化操作

- 对数据库加backup锁，进行备份非innodb表数据，防止阻塞DML语句

  对数据库加lock binlog for backup锁，阻塞对二进制文件修改操作，拷贝完redo日志，记录二进制日志位置，释放锁

#### 25. mysql 行锁实现方式

​	mysql的行锁是通过给索引上的索引向加锁实现的，如果不通过索引检索数据，mysql会加表锁

#### 26. Mysql优化

**原因**：

- 系统吞吐量瓶颈往往是在数据库的访问速度上
- 程序运行的时间越长，数据库的数据越多，处理时间相应变慢
- 数据本上放在磁盘上，读写速度慢

**优化方式**：

- 设计数据库：数据库表，字段设计，存储引擎

  - 字段设计：
    - 尽量使用整型表示字符串
    - 定长和非定长数据类型选择
    - 尽可能选择小的数据类型和指定短的长度
    - 尽可能使用not null
    - 单表字段不要过多

- 利用MySQL自身的功能，如索引

  - 索引;

- 横向扩展：MYsql集群，负载均衡，读写分离

- **SQL语句优化**

  - 查询不要用通配符(like)，会引起全表扫描

    > SELECT * FROM `houdunwang` WHERE `uname` LIKE "%后盾%" -- 不走索引 
    >
    > like后直接跟%不适用索引，而like 后盾%是使用索引的

  - **or**关键字，两边条件必须都是有索引可用，否则会全表扫描

  - 字段要独立出现，不要对字段做运算：

    > SELECT `sname` FROM `stu` WHERE `age`+10=30;-- 不会使用索引，因为所有索引列参与了计算 

    

#### 27.Sql注入

把Sql命令插入到Web表单递交或输入域名或页面请求的查询字符串，达到欺骗服务器执行的恶意Sql命令



#### 28.情况下不应该建立索引

- 对于查询过程中很少使用的列
- 数据值很少的列
- 特殊类型的列(image,text,bit数据类型)
- 修改性能远大于检索性能时

#### 29.Binlog解析

binlog是一个二进制文件，记录了所有的增删查改操作．节点之间的复制就是靠binlog完成.其有三种模式：

- Row模式(推荐)：日志中会记录每一行数据被修改的日志，然后在slave端进行同样的修改.准确性强，能准确复制数据的变更;日志文件大，较大的磁盘Io和网络io
- statement模式：每一条会修改数据的sql都会记录到master的binlog中，slave在复制的时候sql线程会解析成和原来一样的sql语句来执行．日志文件小，节约io，提高性能; 准确性差，有些函数语句无法被复制
- mixed模式：混合模式．准确性强，文件大小适中;可能发生主从不一致问题．

如果执行update操作但是数据库没有发生变化，该操作也会记入binlog

文件结构：

- 文件头：四字节(1852500382)，与java中class文件的魔数0xCAFEBABE功能类似，用于验证文件是否有效
- 事件：通用事件头，私有事件头，事件体
  - 通用事件头：
    - timestamp(4byte):时间的开始执行时间
    - enentType(1byte)：事件类型
    - serverId(4bytes):Mysql服务器的server-id
    - eventLenght(4byte):事件的长度(头部＋数据主体＋校验部分)
    - netPosition(4byte):下一个事件的位置
    - flags(2byte):事件flags
  - 事件体(EventData)：根据不同的类型有不同的解析

#### 30.Mysql复制方式

- 同步复制：在主节点写入数据，所有从服务器都同步完成后才会返回给客户端成功的消息，相对来说较为安全但是耗时长
- 异步复制：主节点接收到客户端的消息执行成功后返回结果，然后再进行主从节点同步，该方式无法保证从节点正确收到主节点消息并执行
- 半同步复制：主节点处理客户端消息，并将数据同步至至少一个从节点后才返回执行成功的消息给客户端

#### 31.为什么非主键索引存放的是主键ID而不是数据行的地址？ 

- 由于行数据和叶子节点存储在一起，这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。

- 辅助索引使用主键作为”指针”  而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个”指针”。也就是说行的位置（实现中通过16K的Page来定位，后面会涉及）会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。



#### 32.B树的插入删除与B+树的插入删除

**B树定义**

B树是一种多路搜索树，一颗m阶B树，满足以下性质：

- 每个节点至多有m个子节点
- 除根节点和叶节点外，其他每个节点至少有m/2(向上取整)-1个节点
- 根节点至少有两个子节点
- 所有叶节点都在同一层
- 有k个子节点的非根节点恰好包含k-1个关键码，关键码按照递增顺序进行排列

**查找**

B树查找很简单，因为B树是二叉排序树的扩展，二叉排序树是二路查找，B树是多路查找。由于B树节点内关键字有序，在节点内进行查找时除了顺序查找外，可以用折半查找来提升效率。具体步骤如下：

- 先让key与根节点中的关键字比较，如果key等于k\[i](k[]为节点内的关键字数组)，则查找成功
- 若key不在节点中关键字数组中,则到对应指针指向的子树中进行查找
- 如果到达叶子节点还未找到该key，则查找不成功

**插入**

插入是指插入一条记录，即(Key,Value)键值对。如果B树中存在需要插入的键值对，则用新的value替换旧的value.如果B树中不存在这个key,则一定是在叶子节点中进行插入操作。

- 根据需要插入的key,找到叶子结点并插入
- 判断当前节点key个数是否小于等于m-1,如果满足则结束，否则进行分裂
- 以节点中间的key为中心分裂成左右两个部分，然后将这个中间的Key插入到父节点中，该key的左子树指向分裂后得到左半部分，右子树指向分裂后的又半部分，然后将当前节点指向父节点。重复该步骤。

说明：

​	节点中将存储记录的数组长度定义为m而非m-1，这样方便底层节点由于分裂向上层插入一个记录时，上层有多余的位置存储该记录。同时，每个节点还存储它父节点的引用，可以不用谢递归程序。

一般来说，对于确定的m和确定类型的记录，节点大小是固定的，无论它实际存储了多少元素。但是分配固定节点大小的方法存在浪费情况。如果记录先按照key的大小排好序，再插入的B树中，节点的使用率会很低，最差情况只有50%.

**删除**

根据Key删除记录，如果B树中的记录不存在对应Key的记录，则删除失败。

- 如果当前需要删除的key位于非叶子节点上，则用后继Key覆盖要删除的key，然后在后继Key所在节点中，删除该后继key.此时后继key(递归的使用后继key覆盖原来的key)一定位于叶子节点上。
- 该节点key个数大于等于Math.ceil(m/2)-1,删除操作结束
- 如果兄弟节点key个数大于Math.ceil(m/2)-1，则父节点中的key下移到该节点，兄弟节点中的一个key上移，删除操作结束
- 否则将父节点中的key下移与当前节点及它的兄弟节点中的key合并，形成一个新的节点。原父节点中的key的两个孩子指针变成了一个孩子指针，指向该新节点。然后当前节点的指针指向父节点。重复第二步。

**B+树**

一颗m阶B+树定义如下：

- 树中非叶子节点最多有m棵子树，同时最多有m-1个关键字
- 根节点至少有两个子树(如果不是叶子节点)，除根节点外，其他非叶子节点至少有m/2(向上取整)棵子树
- 所有节点上的关键字均已排序。
- 所有叶节点位于同一层，并且包含所有信息
- 非叶子节点关键字只充当索引不保存任何具体数据。

**插入**

- 若为空树，创建一个叶子节点，然后将记录插入其中，此时该叶子节点也是根节点，插入结束
- 针对叶子类型节点：根据key找到叶子节点，向该叶子节点插入记录。插入后，若当前节点key的个数小于m-1.插入结束。否则将该叶子节点分裂成两个叶子节点。左叶子节点包含前m/2个记录，右节点包含剩下的记录。将第m/2+1个记录的key上升到父节点中，上升到父节点中的key左孩子指针指向左节点，右孩子指针指向右节点。当前节点的指针指向父节点，执行第三步
- 针对索引类型节点：若当前节点key的个数小于等于m-1，则插入结束。否则，将该索引类型节点分裂成两个索引节点，左索引节点包含前(m-1)/2个key，右节点包含剩下的key,将第m/2个key上升到父节点中，进位到父节点的key左孩子指针指向左节点，**右孩子指针指向右节点。将当前节点的指针指向父节点**?，然后重复该步骤

**删除**

如果叶子节点没有相应的key，删除失败，否则执行下面步骤：

- 删除叶子结点中的key,删除后若节点的key个数满足B+树性质则结束
- 如果兄弟节点key个数大于最小值()(m-1)/2)-1,从兄弟节点借一个记录，同时用该记录替换父节点中得到key，删除结束。
- 如果无法从兄弟节点中借key,则将当前节点和兄弟节点合并成一个新的叶子节点，并删除父节点中的key.当前节点指向父节点
- 如果索引节点key个数满足性质，删除结束。否则，如果兄弟节点有多的key,父节点key下移，兄弟节点key上移，删除结束。
- 当前节点和兄弟节点以及父节点下移的key合并成一个新的节点，当前节点指向父节点。执行第四步

#### 33.为什么MyISAM会比Innodb的查询速度快

- 数据块。InnoDB要缓存，MyISAM只需要缓存索引块，这中间有换进换出的开销。
- InnoDB寻址要映射到块，再到行，MyISAM记录是直接读取文件的Offset，定位比InnnoDB
- InnoDB需要维护MVCC机制。

#### 34.数据库的存储过程

​	简单来说，为了以后的使用而保存的一条或者多条MySQL语句的集合。存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过制定存储过程的名字并给出参数来执行它。

![avatar](https://img-blog.csdn.net/20170321152956539?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbW94aWdhbmRhc2h1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

优点：

- 存储过程可以重复使用，减少开发人员的负担
- 对于网络上的服务器，可以减少网络流量，因为只需要传递存储过程得到名称即可
- 可以防止直接对表的访问，提高系统安全性

#### 35.数据库视图

视图：从一个或者几个基本表中根据用户需要而做成的一个虚表

- 视图只是一个虚表，不存储数据，只存储视图的定义
- 视图只是在刚打开的瞬间，通过定义从基表搜集数据，并展示给用户

与查询的区别：

- 存储上的区别：视图为数据库设计的一部分，而查询不是
- 更新限制的要求不一样，视图也可以用来对表的更新，但是与直接使用update语句更新的限制不同
- 排序结果：视图无法对结果进行排序

**优点**

- 能够分割数据，简化观点，使用户将注意力集中到所关心的数据列，简化浏览数据工作
- 为数据提供一定逻辑性
- 提供安全保护
- 对表进行间接更新



#### 36.Sql各个关键字执行顺序

```sql
Select distinct from join on where group by with  having  order by limit
```

#### 37.数据库各种连接

内连接：返回数据库中连接的两个表**交集部分**

![avatar](https://img-blog.csdn.net/20171209135846780?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGxnMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

左连接：外连接的一种，用于检索连接左侧的表，右侧的表只会讲符合要求的记录显示，没有的地方均为NULL

![avatar](https://img-blog.csdn.net/20171209142610819?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGxnMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

![avatar](https://img-blog.csdn.net/20171209141445680?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcGxnMTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

右连接：与左连接相反

全连接：Mysql不支持该连接





#### 附录

mysql索引原理详解：https://kyle.ai/blog/6439.html



























9